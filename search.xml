<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[模块module.exports与实例化方法]]></title>
      <url>%2F2016%2F12%2F21%2F%E6%A8%A1%E5%9D%97module-exports%E4%B8%8E%E5%AE%9E%E4%BE%8B%E5%8C%96%E6%96%B9%E6%B3%95%2F</url>
      <content type="text"><![CDATA[在nodejs中，提供了exports 和 require 两个对象，其中 exports 是模块公开的接口，require 用于从外部获取一个模块的接口，即所获取模块的 exports 对象。而在exports抛出的接口中，如果你希望你的模块就想为一个特别的对象类型，请使用module.exports；如果希望模块成为一个传统的模块实例，请使用exports.xx方法；module.exports才是真正的接口，exports只不过是它的一个辅助工具。最终返回给调用的是module.exports而不是exports。下面看代码；首先来看module.exports，新建一个hello.js，代码如下： 12345678module.exports=function(name,age,money)&#123; this.name=name; this.age=age; this.money=money; this.say=function()&#123; console.log('我的名字叫：'+this.name+'，我今年'+this.age+'岁，月薪为：'+this.money+'元；') &#125;&#125;; 可以看到，module.exports被赋予了一个构造函数；再新建一个main.js，其中引入hello.js这个模块，把exports方法接受进来，main.js代码如下： 123var Hello=require('./hello');var hello=new Hello('jone','24','10000')hello.say(); 进入node环境，运行main.js，可以看到，已经打印出来：我的名字叫：jone，我今年24岁，月薪为：10000元；而在hello.js中，我们是赋予了exports一个函数 ，当然，也可以采用匿名函数的方式；见代码：123456789function hello(name,age,money)&#123; this.name=name; this.age=age; this.money=money; this.say=function()&#123; console.log('我的名字叫：'+this.name+'，我今年'+this.age+'岁，月薪为：'+this.money+'元；') &#125;&#125;module.exports=hello; 以上module.exports，这个模块很明显是一个特别的对象模型；那如果采用对象实例的方法该如何实现呢？其实也很简单，只需要给exports对象赋值一个新的方法即可；见下面代码： 12345678910function hello(name,age,money)&#123; this.name=name; this.age=age; this.money=money; this.say=function()&#123; console.log('我的名字叫：'+this.name+'，我今年'+this.age+'岁，月薪为：'+this.money+'元；') &#125;&#125;var Hello=new hello('jone','24','10000');exports.add=Hello 在hello.js中，依然是一个构造函数，声明了一个变量Hello，然后再把Hello赋值给exports自定义的add方法；那么在main.js中，由于add已经是exports的一个自定义的实例方法了，因此我们可以直接这么调用它：Hello.add.say()；见代码：12var Hello=require(&apos;./hello&apos;);Hello.add.say() 进行node环境，运行main.js，可以看到，结果和上面一样，都会输出：我的名字叫：jone，我今年24岁，月薪为：10000元；]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[D3入门总结]]></title>
      <url>%2F2016%2F12%2F21%2FD3%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93%2F</url>
      <content type="text"><![CDATA[基础选择元素1d3.select() 选择所有指定元素的第一个1d3.selectAll() 选择指定元素的全部 绑定元素1data() 绑定一个数组到选择集上，数组的各项值分别与选择集的各元素绑定1dataum() 绑定一个数据到选择集上1function(d, i)&#123; &#125; 当选择集需要使用被绑定的数据时，常需要使用匿名函数。其包含两个参数，其中：d 代表数据，也就是与某元素绑定的数据i 代表索引，代表数据的索引号，从 0 开始 插入元素1append() 在选择集末尾插入元素 1insert() 在选择集前面插入元素 删除元素1remove() 添加画布1234var svg = d3.select("body") //选择文档中的body元素 .append("svg") //添加一个svg元素 .attr("width", 300) //设定宽度 .attr("height", 300); //设定高度 绘制矩形12345var dataset = [ 250 , 210 , 170 , 130 , 90 ]; svg.selectAll("rect") //选择svg内所有的矩形 .data(dataset) //绑定数组 .enter() //指定选择集的enter部分 .append("rect") //添加足够数量的矩形元素 有数据，而没有足够图形元素的时候，使用此方法可以添加足够的元素。 矩形的属性，常用的有四个： x - 矩形左上角的 x 坐标 y - 矩形左上角的 y 坐标 width - 矩形的宽度 height - 矩形的高度 注意，在 SVG 中，x 轴的正方向是水平向右，y 轴的正方向是垂直向下的。 比例尺缩放1d3.scale.linear() 返回一个线性比例尺12domain()range() 设定比例尺的定义域和值域12d3.max()d3.min() 求数组的最大值和最小值 线性比例尺1234567891011var dataset = [1.2, 2.3, 0.9, 1.5, 3.3];var min = d3.min(dataset);var max = d3.max(dataset);var linear = d3.scale.linear() .domain([min, max]) .range([0, 300]); linear(0.9); //返回 0linear(2.3); //返回 175linear(3.3); //返回 300 上面的方法将dataset中最小的值，映射成0；将最大的值，映射成 300。 d3.scale.linear() 的返回值，是可以当做函数来使用的。因此，有这样的用法：linear(2.3)，返回175。 序数比例尺12345678910var index = [0, 1, 2, 3, 4];var color = ["red", "blue", "green", "yellow", "black"];var ordinal = d3.scale.ordinal() .domain(index) .range(color);ordinal(0); //返回 redordinal(2); //返回 greenordinal(4); //返回 black 定义坐标轴1d3.svg.axis() D3 中坐标轴的组件，能够在 SVG 中生成组成坐标轴的元素。 要生成坐标轴，需要用到比例尺，它们二者经常是一起使用的。12345678910var dataset = [ 2.5 , 2.1 , 1.7 , 1.3 , 0.9 ];//定义比例尺var linear = d3.scale.linear() .domain([0, d3.max(dataset)]) .range([0, 250]);//定义坐标轴var axis = d3.svg.axis() .scale(linear) //指定比例尺 .orient("bottom") //指定刻度的方向 .ticks(7); //指定刻度的数量 scale()：指定比例尺。 orient()：指定刻度的朝向，bottom 表示在坐标轴的下方显示。 ticks()：指定刻度的数量。 定义了坐标轴之后，只需要在 SVG 中添加一个分组元素 ，再将坐标轴的其他元素添加到这个 里即可1svg.append("g").call(axis); 在 D3 中，call() 的参数是一个函数,调用之后，将当前的选择集作为参数传递给此函数 完整的柱形图 添加 SVG 画布12345678var width = 400;var height = 400;var padding = &#123;left:30, right:30, top:20, bottom:20&#125;;//在 body 里添加一个 SVG 画布 var svg = d3.select("body") .append("svg") .attr("width", width) .attr("height", height); 定义数据和比例尺123456789var dataset = [10, 20, 30, 40, 33, 24, 12, 5];//x轴的比例尺var xScale = d3.scale.ordinal() .domain(d3.range(dataset.length)) .rangeRoundBands([0, width - padding.left - padding.right]);//y轴的比例尺var yScale = d3.scale.linear() .domain([0,d3.max(dataset)]) .range([height - padding.top - padding.bottom, 0]); 定义坐标轴123456789//定义x轴var xAxis = d3.svg.axis() .scale(xScale) .orient("bottom"); //定义y轴var yAxis = d3.svg.axis() .scale(yScale) .orient("left"); 添加矩形和文字元素12345678910111213141516171819202122232425262728293031323334353637383940414243//矩形之间的空白var rectPadding = 4;//添加矩形元素var rects = svg.selectAll(".MyRect") .data(dataset) .enter() .append("rect") .attr("class","MyRect") .attr("transform","translate(" + padding.left + "," + padding.top + ")") .attr("x", function(d,i)&#123; return xScale(i) + rectPadding/2; &#125; ) .attr("y",function(d)&#123; return yScale(d); &#125;) .attr("width", xScale.rangeBand() - rectPadding ) .attr("height", function(d)&#123; return height - padding.top - padding.bottom - yScale(d); &#125;);//添加文字元素var texts = svg.selectAll(".MyText") .data(dataset) .enter() .append("text") .attr("class","MyText") .attr("transform","translate(" + padding.left + "," + padding.top + ")") .attr("x", function(d,i)&#123; return xScale(i) + rectPadding/2; &#125; ) .attr("y",function(d)&#123; return yScale(d); &#125;) .attr("dx",function()&#123; return (xScale.rangeBand() - rectPadding)/2; &#125;) .attr("dy",function(d)&#123; return 20; &#125;) .text(function(d)&#123; return d; &#125;); 添加坐标轴的元素1234567891011//添加x轴svg.append("g") .attr("class","axis") .attr("transform","translate(" + padding.left + "," + (height - padding.bottom) + ")") .call(xAxis); //添加y轴svg.append("g") .attr("class","axis") .attr("transform","translate(" + padding.left + "," + padding.top + ")") .call(yAxis); 过渡效果1transition() 启动过渡效果。 其前后是图形变化前后的状态（形状、位置、颜色等等）1duration() 指定过渡的持续时间，单位为毫秒。1ease() 指定过渡的方式，常用的有： linear：普通的线性变化 circle：慢慢地到达变换的最终状态 elastic：带有弹跳的到达最终状态 bounce：在最终状态处弹跳几次1delay() 指定延迟的时间，表示一定时间后才开始转变，单位同样为毫秒。此函数可以对整体指定延迟，也可以对个别指定延迟。 Update、Enter、Exit如果数组为 [3, 6, 9, 12, 15]，将此数组绑定到3个 p 元素的选择集上。可以想象，会有两个数据没有元素与之对应，这时候 D3 会建立两个空的元素与数据对应，这一部分就称为 Enter。而有元素与数据对应的部分称为 Update。 如果数组为 [3]，则会有两个元素没有数据绑定，那么没有数据绑定的部分被称为 Exit。 update 部分的处理办法一般是：更新属性值 enter 部分的处理办法一般是：添加元素后，赋予属性值 exit 部分的处理办法一般是：删除元素（remove）]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[移动端手势库Hammer.js]]></title>
      <url>%2F2016%2F12%2F18%2F%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%89%8B%E5%8A%BF%E5%BA%93Hammer-js%2F</url>
      <content type="text"><![CDATA[Github Hammer.js是一个开源的，轻量级的javascript库，它可以在不需要依赖其他东西的情况下识别触摸，鼠标事件。 使用引入hammer.js到文件中，并创建一个新的实例：1234var hammer = new Hammer(Element, Options);hammer.on('tap', function(ev) &#123; console.log(ev);&#125;); hammerjs内置多种手势识别器，包括 tap：轻触，与click相比有300ms的延迟 doubletap：双点击 press：按住,最小按压时间为500毫秒 pan：拖动平移 panstart：拖动开始 panmove：拖动过程 panend：拖动结束 pancancel：拖动取消 panleft：向左拖动 panright：向右拖动 panup：向上拖动 pandown：向下拖动 swipe：快速滑动 swipeleft：向左滑动 swiperight：向右滑动 swipeup：向上滑动 swipedown：向下滑动 pinch：多触点捏放 pinchstart：多点触控开始 pinchmove：多点触控过程 pinchend：多点触控结束 pinchcancel：多点触控取消 pinchin：多点触控时两手指距离越来越近 pinchout：多点触控时两手指距离越来越远 rotate：旋转识别器 rotatestart：旋转开始 rotatemove：旋转过程 rotateend：旋转结束 rotatecancel：旋转取消 其中 pinch 和 rotate 默认是不可用的，想启用它们，需要加上： 12hammer.get('pinch').set(&#123; enable: true &#125;);hammer.get('rotate').set(&#123; enable: true &#125;); pan 和 swipe默认只识别水平方位的手势，若要允许识别器识别垂直方位或全部方位的 pan 和 swipe，可以这么写： 12hammer.get('pan').set(&#123; direction: Hammer.DIRECTION_ALL &#125;);hammer.get('swipe').set(&#123; direction: Hammer.DIRECTION_VERTICAL &#125;); 另建议加上如下meta标签，防止doubletap 或 pinch 缩放了viewport： 1&lt;meta name="viewport" content="user-scalable=no, width=device-width, initial-scale=1, maximum-scale=1"&gt; 事件对象 每一个Hammer触发的事件都会收到一个包含了如下属性的事件对象： on(events, handler) 和 .off(events, [handler]) 监听由被添加的识别器触发的事件，或者移除那些绑定了的事件。参数中将事件通过空格隔开可处理多个事件 在jQuery基础上使用123456$("#element").hammer(&#123; // 对DOM进行一些初始化，这里可以加入一些参数 &#125;) .on("tap", function(ev) &#123; console.log(ev); &#125;);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hexo博客命令]]></title>
      <url>%2F2016%2F12%2F18%2Fhello-world%2F</url>
      <content type="text"><![CDATA[写在第一页，作为建立个人博客的第一篇文章，使用Hexo搭建，记录日常使用的常用命令。本博客使用品Next主题。精于心，简于形 快速开始创建新文章1$ hexo new post "My New Post" 创建新页面1$ hexo new page "My New Page" 更多信息 启动服务器1$ hexo server 更多信息 生成静态文件1$ hexo generate 更多信息 发布到远程服务器1$ hexo deploy 更多信息]]></content>
    </entry>

    
  
  
</search>
