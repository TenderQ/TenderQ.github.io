<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[使用artTemplate模板引擎开发网站]]></title>
      <url>%2F2016%2F12%2F28%2F%E4%BD%BF%E7%94%A8artTemplate%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E%E5%BC%80%E5%8F%91%E7%BD%91%E7%AB%99%2F</url>
      <content type="text"><![CDATA[artTemplateartTemplate是一款性能卓越的 javascript 模板引擎。它采用预编译方式让性能有了质的飞跃，并且充分利用 javascript 引擎特性，使得其性能无论在前端还是后端都有极其出色的表现。在 chrome 下渲染效率测试中分别是知名引擎 Mustache 与 micro tmpl 的 25 、 32 倍（性能测试）。除了性能优势外，调试功能也值得一提。模板调试器可以精确定位到引发渲染错误的模板语句，解决了编写模板过程中无法调试的痛苦，让开发变得高效，也避免了因为单个模板出错导致整个应用崩溃的情况发生。 下载： 简洁语法版(推荐) 、 原生语法版 、 Github 特性 性能卓越，执行速度通常是 Mustache 与 tmpl 的 20 多倍（性能测试） 支持运行时调试，可精确定位异常模板所在语句（演示） 对 NodeJS Express 友好支持 安全，默认对输出进行转义、在沙箱中运行编译后的代码（Node版本可以安全执行用户上传的模板） 支持include语句，可在浏览器端实现按路径加载模板 支持预编译，可将模板转换成为非常精简的 js 文件 模板语句简洁，无需前缀引用数据 支持所有流行的浏览器 作为前端模版引擎快速上手编写模版创建一个html文件，引入template.js，然后在正文中放置一个id为content的div标签，用来存放接下来根据模板动态生成的html内容。12345678910&lt;html&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;demo&lt;/title&gt; &lt;script src="template.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=”content”&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 使用一个type=&quot;text/html&quot;的script标签存放模板：12345678&lt;script id="test" type="text/html"&gt; &lt;h1&gt;&#123;&#123;title&#125;&#125;&lt;/h1&gt; &lt;ul&gt; &#123;&#123;each list as value i&#125;&#125; &lt;li&gt;索引 &#123;&#123;i + 1&#125;&#125; ：&#123;&#123;value&#125;&#125;&lt;/li&gt; &#123;&#123;/each&#125;&#125; &lt;/ul&gt;&lt;/script&gt; 渲染模版12345678&lt;script&gt;var data = &#123; title: '标签', list: ['文艺', '博客', '摄影', '电影', '民谣', '旅行', '吉他']&#125;;var html = template.render('test', data);document.getElementById('content').innerHTML = html;&lt;/script&gt; 演示 不转义HTML模板引擎默认数据包含的 HTML 字符进行转义以避免 XSS 漏洞，若不需要转义的地方可使用==。123&lt;script id="test" type="text/html"&gt; &#123;&#123;#value&#125;&#125;&lt;/script&gt; 若需要关闭默认转义，可以设置template.isEscape = false。演示 在js中存放模板template.compile([id], source)将返回一个渲染函数。其中 id 参数是可选的，如果使用了 id 参数，可以使用template.render(id, data)渲染模板。1234567891011121314&lt;script&gt;var source = '&lt;ul&gt;'+ '&#123;&#123;each list as value i&#125;&#125;'+ '&lt;li&gt;索引 &#123;&#123;i + 1&#125;&#125; ：&#123;&#123;value&#125;&#125;&lt;/li&gt;'+ '&#123;&#123;/each&#125;&#125;'+ '&lt;/ul&gt;';var render = template.compile(source);var html = render(&#123; list: ['摄影', '电影', '民谣', '旅行', '吉他']&#125;);document.getElementById('content').innerHTML = html;&lt;/script&gt; 演示 添加辅助方法template.helper(name, callback)辅助方法一般用来进行输出字符串或字符串替换。例如编写一个显示当前时间的辅助方法：12345678910template.helper('dateFormat', function (date, format) &#123; //.. return value;&#125;);var data = &#123; time: (new Date).toString(),&#125;;var html = template('test', data);document.getElementById('content').innerHTML = html; 在模板中的使用方式：1&#123;&#123;time | dateFormat:'yyyy年 MM月 dd日 hh:mm:ss'&#125;&#125; 支持传入参数与嵌套使用：1&#123;&#123;time | say:'cd' | ubb | link&#125;&#125; 注意：引擎不会对辅助方法输出的 HTML 字符进行转义。演示 作为后端引擎使用(配合node.js)安装art-template1npm install art-template --save 编写artTemplate模板在工作区下，创建index.html，并将如下代码输入index.html，保存。其中&lt;ul&gt;标签中的内容，就是模板代码。1234567&lt;div id='main'&gt; &lt;ul&gt; &#123;&#123;each list&#125;&#125; &lt;li&gt;编号：&#123;&#123;$value.id&#125;&#125; &amp;nbsp;&amp;nbsp;姓名：&#123;&#123;$value.name&#125;&#125;&lt;/a&gt;&lt;/li&gt; &#123;&#123;/each&#125;&#125; &lt;/ul&gt;&lt;/div&gt; 渲染模板还记得template(id, data)方法吗？这是在前端DOM环境下的用法。 其实在NodeJS环境下，它就相当于template(filename, data)了，可以将需要渲染的模板文件名当作路径传给它的第一个参数。12345678910111213var http = require('http');var os = require('os');http.createServer(function(request, response) &#123; var template = require('art-template'); //数据 var data = &#123;list: [&#123;id:'1', name:'张三'&#125;, &#123;id:'2', name:'李四'&#125;]&#125;; //渲染模板 var html = template('./index', data); response.writeHead(200, &#123;'Content-Type': 'text/html'&#125;); response.write(html); response.end();&#125;).listen(3000);console.log("Server is running, listening on port 3000…"); 配置base指定模板目录可以缩短模板的路径，并且能够避免include语句越级访问任意路径引发安全隐患。例如：12template.config('base', __dirname);var html = template('index/main', data) 在Windows命令行下，进入工作区，执行node server.js，服务器就启动了。 此时在本地机器上使用浏览器访问http://localhost:3000将会看到Html输出了。 搭配express使用express框架是由javascript语言开发的，基于Node.js平台的，快速、开放、极简的web开发框架。 安装art-template1npm install art-template --save 改造app.jsapp.js是express的主要文件，这个文件里包含了指定模板引擎、指定视图文件默认路径的代码。需要将指定模板引擎的代码改为指定用art-template引擎。视图文件默认路径保持不变，因此无需改动。123456789//首先，引入artTemplate模块var template = require('art-template');//用art-template引擎替换默认的jade引擎template.config('base', '');template.config('extname', '.html');app.engine('.html', template.__express);app.set('view engine', 'html');//app.set('view engine', 'jade'); 编写artTemplate模板进入express文件夹中的views子文件夹，创建index.html，并将如下代码输入index.html，并保存。1234567&lt;div id='main'&gt; &lt;ul&gt; &#123;&#123;each list as value i&#125;&#125; &lt;li&gt;索引 &#123;&#123;i + 1&#125;&#125; ：&#123;&#123;value&#125;&#125;&lt;/li&gt; &#123;&#123;/each&#125;&#125; &lt;/ul&gt;&lt;/div&gt; 渲染模版express默认访问index路由。进入routes文件夹，打开router.js，增加渲染模板的代码，如下：123456789router.get('/', function(req, res, next) &#123; // 数据 var data = &#123; title: '标签', list: ['文艺', '博客', '摄影', '电影', '民谣', '旅行', '吉他'] &#125;; // 渲染模板 res.render('index', data);&#125;); 代码中的res.render(&#39;index&#39;, data)调用，会调用artTemple模块中的template.__express方法，并传入模板文件名、数据。 template.__express方法是在app.js中注册给express框架的。 预编译工具使用预编译工具可以让前端模版不再受浏览器的限制，支持如后端模版一样按文件放置、include 语句等特性，可以像后端一样书写前端模板！ 编译后的模板不再依赖前端模板引擎与后端，模板可以通过 SeaJS 或 RequireJS 等加载器进行异步加载，亦能利用它们成熟的打包合并工具进行上线前的优化，如合并与压缩。 预编译工具：TmodJS TmodJS 一经启动，就无需人工干预，每次模板创建与更新都会自动编译，引入一个 js 即可使用template(path)接口调用本地模板文件，直到正式上线都无需对代码进行任何修改，整个过程简单自然。 安装TmodJS1npm install -g tmodjs 编译模板只需要运行tmod这个命令即可，默认配置参数可以满足绝大多数项目。1tmod [模板目录] [配置参数] 模板目录必须是模板的根目录，若无参数则为默认使用当前工作目录，tmodjs 会监控模板目录修改，每次模板修改都会增量编译。 配置参数 --debug 输出调试版本 --charset value 定义模板编码，默认utf-8 --output value 定义输出目录，默认./build --type value 定义输出模块格式，默认default，可选cmd、amd、commonjs --no-watch 关闭模板目录监控 --version 显示版本号 --help 显示帮助信息 配置参数将会保存在模板目录配置文件中，下次运行无需输入配置参数（–no-watch 与 –debug 除外）。 示例1tmod ./tpl --output ./build 使用模板根据编译的type的配置不同，会有两种不同使用方式： 使用默认的格式TmodJS 默认将整个目录的模板压缩打包到一个名为 template.js 的脚本中，可直接在页面中使用它：12345&lt;script src="tpl/build/template.js"&gt;&lt;/script&gt;&lt;script&gt; var html = template('news/list', _list); document.getElementById('list').innerHTML = html;&lt;/script&gt; template.js 还支持 RequireJS、SeaJS、NodeJS 加载。示例 指定格式（amd / cmd / commonjs)此时每个模板就是一个单独的模块，无需引用 template.js： 12var render = require('./tpl/build/news/list');var html = render(_list); 注意：模板路径不能包含模板后缀名 演示TmodJS 源码包中test/tpl是一个演示项目的前端模板目录，基于默认配置。切换到源码目录后，编译： 1tmod test/tpl 编译完毕后你可以在浏览器中打开 test/index.html 查看如何使用编译后的模板。 配置TmodJS 的项目配置文件保存在模板目录的 package.json 文件中： 1234567891011121314151617181920&#123; "name": "template", "version": "1.0.0", "dependencies": &#123; "tmodjs": "1.0.0" &#125;, "tmodjs-config": &#123; "output": "./build", "charset": "utf-8", "syntax": "simple", "helpers": null, "escape": true, "compress": true, "type": "default", "runtime": "template.js", "combo": true, "minify": true, "cache": false &#125;&#125; 字段 类型 默认值 说明 output String &quot;./build&quot; 编译输出目录设置。如果设置为 false 则不输出 charset String &quot;utf-8&quot; 模板使用的编码（暂时只支持 utf-8） syntax String &quot;simple&quot; 定义模板采用哪种语法。可选：simple、native helpers String null 自定义辅助方法路径 escape Boolean true 是否过滤 XSS。如果后台给出的数据已经进行了 XSS 过滤，就可以关闭模板的过滤以提升模板渲染效率 compress Boolean true 是否压缩 HTML 多余空白字符 type String &quot;default&quot; 输出的模块类型，可选：default、cmd、amd、commonjs runtime String &quot;template.js&quot; 设置输出的运行时名称 alias String null 设置模块依赖的运行时路径（仅针对于非default的类型模块配置字段。如果不指定模块内部会自动使用相对 runtime 的路径） combo Boolean true 是否合并模板（仅针对于 default 类型的模块） minify Boolean true 是否输出为压缩的格式 cache Boolean true 是否开启编译缓存 verbose Boolean true 是否打印日志]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Loader.css - CSS3实现加载动画]]></title>
      <url>%2F2016%2F12%2F23%2FLoader-css-CSS3%E5%AE%9E%E7%8E%B0%E5%8A%A0%E8%BD%BD%E5%8A%A8%E7%94%BB%2F</url>
      <content type="text"><![CDATA[当网页的页面大小较大，用户加载可能需要较长的时间，在这些情况下，我们一般会用到（加载）loading动画，提示于用户页面在加载中，这些UX常识我想很多设计师都懂，但做一个GIF动画有点麻烦，为了方便，为大家分享Loader.css，仅用CSS3就能实现一个loading动画效果。Loader.css当前支持28个动画效果。 使用方法Step 1: 引入 loaders.min.css 和 loaders.css.js，这个JS仅是为了简化动画的DIV标签，如果不加这个JS，那么你的动画就必须加上对应数量DIV标签才能正常显示动画，所以建议加上，这样语义化好会好些。12&lt;link rel="stylesheet" type="text/css" href="loaders.min.css"&gt;&lt;script type="text/javascript" src="loaders.css.js"&gt;&lt;/script&gt; Step 2: HTML代码，给loading元素加入动画class，如下：1&lt;div class="loader-inner ball-pulse"&gt;&lt;/div&gt; 改变加载动画颜色此外你还要可以为loading动画加上颜色，代码如下：123.ball-grid-pulse &gt; div &#123; background: orange;&#125; 浏览器兼容性 IE 11 Firefox 36 Chrome 41 Safari 8 ✔ ✔ ✔ ✔ 虽然不兼容IE8或以下版本，但我觉得已经够用了，目前现在用IE10和手机浏览网页的用户也很多了。 在线预览DEMO下载地址]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Js模块化开发]]></title>
      <url>%2F2016%2F12%2F23%2FJs%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91%2F</url>
      <content type="text"><![CDATA[前言前端开发中，起初只要在script标签中嵌入几十上百行代码就能实现一些基本的交互效果，后来js得到重视，应用也广泛起来了，jQuery，Ajax，Node.Js，MVC，MVVM等的助力也使得前端开发得到重视，也使得前端项目越来越复杂，然而，JavaScript却没有为组织代码提供任何明显帮助，甚至没有类的概念，更不用说模块（module）了，那么什么是模块呢？ 一个模块就是实现特定功能的文件，有了模块，我们就可以更方便地使用别人的代码，想要什么功能，就加载什么模块。模块开发需要遵循一定的规范，否则就都乱套了。根据AMD规范，我们可以使用define定义模块，使用require调用模块。目前，通行的js模块规范主要有两种：CommonJS和AMD。 AMD规范AMD 即Asynchronous Module Definition，中文名是“异步模块定义”的意思。它是一个在浏览器端模块化开发的规范，服务器端的规范是CommonJS模块将被异步加载，模块加载不影响后面语句的运行。所有依赖某些模块的语句均放置在回调函数中。AMD 是 RequireJS 在推广过程中对模块定义的规范化的产出。 define() 函数AMD规范只定义了一个函数 define，它是全局变量。函数的描述为：1define(id?, dependencies?, factory); 参数说明： id：指定义中模块的名字，可选；如果没有提供该参数，模块的名字应该默认为模块加载器请求的指定脚本的名字。如果提供了该参数，模块名必须是“顶级”的和绝对的（不允许相对名字）。 依赖dependencies：是一个当前模块依赖的，已被模块定义的模块标识的数组字面量。依赖参数是可选的，如果忽略此参数，应该默认为[“require”, “exports”, “module”]。然而，如果工厂方法的长度属性小于3，加载器会选择以函数的长度属性指定的参数个数调用工厂方法。 工厂方法factory：模块初始化要执行的函数或对象。如果为函数，它应该只被执行一次。如果是对象，此对象应该为模块的输出值。 模块名的格式模块名用来唯一标识定义中模块，它们同样在依赖性数组中使用： 模块名是用正斜杠分割的有意义单词的字符串 单词须为驼峰形式，或者”.”，”..” 模块名不允许文件扩展名的形式，如“.js” 模块名可以为 “相对的” 或 “顶级的”。如果首字符为“.”或“..”则为相对的模块名 顶级的模块名从根命名空间的概念模块解析 相对的模块名从 “require” 书写和调用的模块解析 使用 require 和 exports创建一个名为”alpha”的模块，使用了require，exports，和名为”beta”的模块:123456define("alpha", ["require", "exports", "beta"], function (require, exports, beta) &#123; exports.verb = function() &#123; return beta.verb(); //Or:return require("beta").verb(); &#125; &#125;); require API 介绍 目前，实现AMD的库有RequireJS、curl 、Dojo 、Nodules 等。 CommonJS规范CommonJS是服务器端模块的规范，Node.js采用了这个规范。Node.JS首先采用了js模块化的概念。根据CommonJS规范，一个单独的文件就是一个模块。每一个模块都是一个单独的作用域，也就是说，在该模块内部定义的变量，无法被其他模块读取，除非定义为global对象的属性。输出模块变量的最好方法是使用module.exports对象。 123456789var i = 1;var max = 30;module.exports = function () &#123; for (i -= 1; i++ &lt; max; ) &#123; console.log(i); &#125; max *= 1.1;&#125;; 上面代码通过module.exports对象，定义了一个函数，该函数就是模块外部与内部通信的桥梁。 加载模块使用require方法，该方法读取一个文件并执行，最后返回文件内部的module.exports对象。 AMD和CMDCMD（Common Module Definition）通用模块定义。该规范明确了模块的基本书写格式和基本交互规则。该规范是在国内发展出来的。AMD是依赖关系前置，CMD是按需加载。在 CMD 规范中，一个模块就是一个文件。代码的书写格式如下：1define(factory); factory 为函数时，表示是模块的构造方法。执行该构造方法，可以得到模块向外提供的接口。factory 方法在执行时，默认会传入三个参数：require、exports 和 module：12345define(function(require, exports, module) &#123; // 模块代码&#125;); require是可以把其他模块导入进来的一个参数，而export是可以把模块内的一些属性和方法导出的。 CMD规范 AMD 是 RequireJS 在推广过程中对模块定义的规范化产出。CMD 是 SeaJS 在推广过程中对模块定义的规范化产出。对于依赖的模块，AMD 是提前执行，CMD 是延迟执行。AMD:提前执行（异步加载：依赖先执行）+延迟执行CMD:延迟执行（运行到需加载，根据顺序执行）CMD 推崇依赖就近，AMD 推崇依赖前置。看如下代码：123456789// CMDdefine(function(require, exports, module) &#123; var a = require('./a') a.doSomething() // 此处略去 100 行 var b = require('./b') // 依赖可以就近书写 b.doSomething() // ... &#125;) 1234567// AMD 默认推荐的是define(['./a', './b'], function(a, b) &#123; // 依赖必须一开始就写好 a.doSomething() // 此处略去 100 行 b.doSomething() ...&#125;) 另外一个区别是：AMD:API根据使用范围有区别，但使用同一个api接口CMD:每个API的职责单一AMD的优点是：异步并行加载，在AMD的规范下，同时异步加载是不会产生错误的。CMD的机制则不同，这种加载方式会产生错误，如果能规范化模块内容形式，也可以jquery1.7以上版本会自动模块化，支持AMD模式：主要是使用define函数，sea.js虽然是CommonJS规范，但却使用了define来定义模块所以jQuery已经自动模块化了123456seajs.config(&#123; 'base':'/', 'alias':&#123; 'jquery':'jquery.js'//定义jQuery文件 &#125;&#125;); define函数和AMD的define类似：1234567define(function(require, exports, module)&#123; //先要载入jQuery的模块 var $ = require('jquery'); //然后将jQuery对象传给插件模块 require('./cookie')($); //开始使用 $.cookie方法&#125;); RequireJS和SeaJSRequireJS由James Burke创建，他也是AMD规范的创始人。define方法用于定义模块，RequireJS要求每个模块放在一个单独的文件里。RequireJS 和 Sea.js 都是模块加载器，倡导模块化开发理念，核心价值是让 JavaScript 的模块化开发变得简单自然。 SeaJS与RequireJS最大的区别:SeaJS对模块的态度是懒执行, 而RequireJS对模块的态度是预执行 不明白？看这篇图文并茂的文章吧 Requirejs为什么要用requireJS试想一下，如果一个网页有很多的js文件，那么浏览器在下载该页面的时候会先加载js文件，从而停止了网页的渲染，如果文件越多，浏览器可能失去响应。其次，要保证js文件的依赖性，依赖性最大的模块（文件）要放在最后加载，当依赖关系很复杂的时候，代码的编写和维护都会变得困难。RequireJS就是为了解决这两个问题而诞生的：（1）实现js文件的异步加载，避免网页失去响应；（2）管理模块之间的依赖性，便于代码的编写和维护。RequireJS文件下载 使用require.config是用来定义别名的，在paths属性下配置别名。然后通过requirejs(参数一，参数二)；参数一是数组，传入我们需要引用的模块名，第二个参数是个回调函数，回调函数传入一个变量，代替刚才所引入的模块。 12345678910//别名配置requirejs.config(&#123; paths: &#123; jquery: 'jquery.min'//可以省略.js &#125;&#125;);//引入模块，用变量$表示jquery模块requirejs(['jquery'], function ($) &#123; $('body').css('background-color','red');&#125;); 引入模块也可以只写require()。requirejs通过define()定义模块，定义的参数上同。在此模块内的方法和变量外部是无法访问的，只有通过return返回才行.define 模块123456define(['jquery'], function ($) &#123;//引入jQuery模块return &#123; add: function(x,y)&#123; return x + y; &#125; &#125;;&#125;); 将该模块命名为math.js保存。main.js引入模块方法123require(['jquery','math'], function ($,math) &#123; console.log(math.add(10,100));//110&#125;); 如果定义的模块不依赖其他模块，则可以：123456define(function () &#123; return &#123; name: "trigkit4", age: "21" &#125;&#125;); AMD推荐的风格通过返回一个对象做为模块对象，CommonJS的风格通过对module.exports或exports的属性赋值来达到暴露模块对象的目的。 Sea.js如何使用？引入sea.js的库 如何变成模块？ define 如何调用模块？ exports sea.js.use 如何依赖模块？ require 1234567&lt;script type="text/javascript"&gt; define(function (require,exports,module) &#123; //exports : 对外的接口 //requires : 依赖的接口 require('./test.js'); //如果地址是一个模块的话，那么require的返回值就是模块中的exports &#125;)&lt;/script&gt; sea.js 开发实例123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type"content="text/html; charset=utf-8" /&gt;&lt;title&gt;鼠标拖拽的模块化开发实践&lt;/title&gt;&lt;styletype="text/css"&gt;#div1&#123; width:200px; height:200px; background:black; position:absolute; display:none;&#125;#div2&#123; width:30px; height:30px; background:yellow; position:absolute; bottom:0; right:0;&#125;#div3&#123; width:100px; height:100px; background:blue; position:absolute; right:0; top:0;&#125;&lt;/style&gt;&lt;script type="text/javascript" src="./sea.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt;//A同事 ：seajs.use('./main.js');&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;input type="button" value="确定" id="input1" /&gt; &lt;div id="div1"&gt; &lt;div id="div2"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div id="div3"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; A同事1234567891011121314151617//A同事写的main.js:define(function (require,exports,module) &#123; var oInput = document.getElementById('input1'); var oDiv1 = document.getElementById('div1'); var oDiv2 = document.getElementById('div2'); var oDiv3 = document.getElementById('div3'); require('./drag.js').drag(oDiv3); oInput.onclick = function () &#123; oDiv1.style.display = 'block'; require('./scale.js').scale(oDiv1,oDiv2); require.async('./scale.js', function (ex) &#123; ex.scale(oDiv1,oDiv2); &#125;) &#125;&#125;); B同事123456789101112131415161718192021222324252627//B同事写的drag.js:define(function(require,exports,module)&#123; function drag(obj)&#123; var disX = 0; var disY = 0; obj.onmousedown = function(ev)&#123; var ev = ev || window.event; disX = ev.clientX - obj.offsetLeft; disY = ev.clientY - obj.offsetTop; document.onmousemove = function(ev)&#123; var ev = ev || window.event; var L = require('./range.js').range(ev.clientX - disX , document.documentElement.clientWidth - obj.offsetWidth , 0 ); var T = require('./range.js').range(ev.clientY - disY , document.documentElement.clientHeight - obj.offsetHeight , 0 ); obj.style.left = L + 'px'; obj.style.top = T + 'px'; &#125;; document.onmouseup = function()&#123; document.onmousemove = null; document.onmouseup = null; &#125;; return false; &#125;; &#125; exports.drag = drag;//对外提供接口&#125;); C同事1234567891011121314151617181920212223242526272829303132//C同事写的scale.js:define(function(require,exports,module)&#123; function scale(obj1,obj2)&#123; var disX = 0; var disY = 0; var disW = 0; var disH = 0; obj2.onmousedown = function(ev)&#123; var ev = ev || window.event; disX = ev.clientX; disY = ev.clientY; disW = obj1.offsetWidth; disH = obj1.offsetHeight; document.onmousemove = function(ev)&#123; var ev = ev || window.event; var W = require('./range.js').range(ev.clientX - disX + disW , 500 , 100); var H = require('./range.js').range(ev.clientY - disY + disH , 500 , 100); obj1.style.width = W + 'px'; obj1.style.height = H + 'px'; &#125;; document.onmouseup = function()&#123; document.onmousemove = null; document.onmouseup = null; &#125;; return false; &#125;; &#125; exports.scale = scale;&#125;); D同事123456789101112131415// D同事的range.js--限定拖拽范围define(function(require,exports,module)&#123; function range(iNum,iMax,iMin)&#123; if( iNum &gt; iMax )&#123; return iMax; &#125; elseif( iNum &lt; iMin )&#123; return iMin; &#125; else&#123; return iNum; &#125; &#125; exports.range = range;&#125;);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Promise实现原理]]></title>
      <url>%2F2016%2F12%2F22%2FPromise%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%2F</url>
      <content type="text"><![CDATA[Promise 对于一个Jser并不陌生， Promise 类似于一个事务管理器，它的作用就是将各种内嵌回调的事务用流水形式表达。利用 Promise 可以让异步编程更符合人的直觉，让代码逻辑更加清晰，把开发人员从回调地狱中释放出来。这么“高大上”的东西，以前写 nodejs 代码的时候只是简单的用用，还没有理解其基本的实现原理，罪过！个人认为，理解编程思想最好的途径就是阅读一份简易的实现源码。很幸运，网上有不少Promise的简易实现，下面就来好好研究下吧！ 基础概念目前， Promise 是ECMAScript 6 规范的重要特性之一，各大浏览器也开始慢慢支持这一特性。当然，也有一些第三方内库实现了该功能，最流行的如：bluebird等。Promise 对象用来进行延迟( deferred )和异步( asynchronous )计算。一个Promise 处于以下四种状态之一: pending: 还没有得到肯定或者失败结果，进行中 fulfilled: 成功的操作 rejected: 失败的操作 settled: 已被 fulfilled 或 rejected Promise 对象有两个重要的方法，一个是 then ，另一个是 resolve ： then：将事务添加到事务队列中 resolve：开启流程，让整个操作从第一个事务开始执行 Promise 常用方式如下：1234567891011var p = new Promise(function(resolve, reject) &#123; ... // 事务触发 resovle(xxx); ...&#125;);p.then(function(value) &#123; // 满足 &#125;, function(reason) &#123; // 拒绝&#125;).then().then()... 示意图如下： 实现步骤 Promise 其实就是一个状态机。按照它的定义，可从如下基础代码开始： 123456789101112131415161718192021var PENDING = 0; // 进行中 var FULFILLED = 1; // 成功 var REJECTED = 2; // 失败function Promise() &#123; // 存储PENDING, FULFILLED或者REJECTED的状态 var state = PENDING; // 存储成功或失败的结果值 var value = null; // 存储成功或失败的处理程序，通过调用`.then`或者`.done`方法 var handlers = []; // 成功状态变化 function fulfill(result) &#123; state = FULFILLED; value = result; &#125; // 失败状态变化 function reject(error) &#123; state = REJECTED; value = error; &#125;&#125; 下面是 Promise 的 resolve 方法实现：注意：resolve 方法可接收的参数有两种：一个普通的值/对象或者一个 Promise对象。如果是普通的值/对象，则直接把结果传递到下一个对象；如果是一个Promise 对象，则必须先等待这个子任务序列完成。 1234567891011121314151617function Promise() &#123; ... function resolve(result) &#123; try &#123; var then = getThen(result); // 如果是一个promise对象 if (then) &#123; doResolve(then.bind(result), resolve, reject); return; &#125; // 修改状态，传递结果到下一个事务 fulfill(result); &#125; catch (e) &#123; reject(e); &#125; &#125;&#125; 两个辅助方法： 12345678910111213141516171819202122232425262728293031323334353637383940/** * 检查值是否是一个Promise，如果是，返回这个Promise的 `then`方法。 * @param &#123;Promise|Any&#125; value * @return &#123;Function|Null&#125; */function getThen(value) &#123; var t = typeof value; if (value &amp;&amp; (t === 'object' || t === 'function')) &#123; var then = value.then; if (typeof then === 'function') &#123; return then; &#125; &#125; return null;&#125;/** * 确保onfulfilled和onrejected只调用一次。 * * @param &#123;Function&#125; fn * @param &#123;Function&#125; onFulfilled * @param &#123;Function&#125; onRejected */ function doResolve(fn, onFulfilled, onRejected) &#123; var done = false; try &#123; fn(function(value) &#123; if (done) return; done = true; onFulfilled(value); &#125;, function(reason) &#123; if (done) return; done = true; onRejected(reason); &#125;); &#125; catch(ex) &#123; if (done) return; done = true; onRejected(ex); &#125; &#125; 上面已经完成了一个完整的内部状态机，但我们并没有暴露一个方法去解析或则观察 Promise 。现在让我们开始解析 Promise ： 1234function Promise(fn) &#123; ... doResolve(fn, resolve, reject);&#125; 如你所见，我们复用了 doResolve，因为对于初始化的 fn 也要对其进行控制。fn 允许调用 resolve 或则 reject 多次，甚至抛出异常。这完全取决于我们去保证 promise 对象仅被 resolved 或则 rejected 一次，且状态不能随意改变。 目前，我们已经有了一个完整的状态机，但我们仍然没有办法去观察它的任何变化。我们最终的目标是实现 then 方法，但 done 方法似乎更简单，所以先实现它。我们的目标是实现 promise.done(onFullfilled, onRejected) : onFulfilled 和 onRejected 两者只能有一个被执行，且执行次数为一次 该方法仅能被调用一次 一旦调用了该方法，则 promise 链式调用结束 无论是否 promise 已经被解析，都可以调用该方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869var PENDING = 0; // 进行中 var FULFILLED = 1; // 成功 var REJECTED = 2; // 失败function Promise() &#123; // 存储PENDING, FULFILLED或者REJECTED的状态 var state = PENDING; // 存储成功或失败的结果值 var value = null; // 存储成功或失败的处理程序，通过调用`.then`或者`.done`方法 var handlers = []; // 成功状态变化 function fulfill(result) &#123; state = FULFILLED; value = result; handlers.forEach(handle); handlers = null; &#125; // 失败状态变化 function reject(error) &#123; state = REJECTED; value = error; handlers.forEach(handle); handlers = null; &#125; function resolve(result) &#123; try &#123; var then = getThen(result); if (then) &#123; doResolve(then.bind(result), resolve, reject) return &#125; fulfill(result); &#125; catch (e) &#123; reject(e); &#125; &#125; // 不同状态，进行不同的处理 function shandle(handler) &#123; if (state === PENDING) &#123; handlers.push(handler); &#125; else &#123; if (state === FULFILLED &amp;&amp; typeof handler.onFulfilled === 'function') &#123; handler.onFulfilled(value); &#125; if (state === REJECTED &amp;&amp; typeof handler.onRejected === 'function') &#123; handler.onRejected(value); &#125; &#125; &#125; this.done = function (onFulfilled, onRejected) &#123; // 保证异步 setTimeout(function () &#123; handle(&#123; onFulfilled: onFulfilled, onRejected: onRejected &#125;); &#125;, 0); &#125; doResolve(fn, resolve, reject);&#125; 当 Promise 被 resolved 或者 rejected 时，我们保证 handlers 将被通知。 现在我们已经实现了 done 方法，下面实现 then 方法就很容易了。需要注意的是，要在处理程序中新建一个Promise 。123456789101112131415161718192021222324252627this.then = function (onFulfilled, onRejected) &#123; var self = this; return new Promise(function (resolve, reject) &#123; return self.done(function (result) &#123; if (typeof onFulfilled === 'function') &#123; try &#123; // onFulfilled方法要有返回值！ return resolve(onFulfilled(result)); &#125; catch (ex) &#123; return reject(ex); &#125; &#125; else &#123; return resolve(result); &#125; &#125;, function (error) &#123; if (typeof onRejected === 'function') &#123; try &#123; return resolve(onRejected(error)); &#125; catch (ex) &#123; return reject(ex); &#125; &#125; else &#123; return reject(error); &#125; &#125;); &#125;);&#125; 测试完成了上面的代码，测试就很容易了。测试实例来自MDN：1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;&lt;meta charset="UTF-8"&gt;&lt;title&gt;promise test&lt;/title&gt;&lt;script src="./mypromise.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;button id="test"&gt;promise test&lt;/button&gt;&lt;div id="log"&gt;&lt;/div&gt;&lt;script&gt; var promiseCount = 0; function testPromise() &#123; var thisPromiseCount = ++promiseCount; var log = document.getElementById('log'); log.insertAdjacentHTML('beforeend', thisPromiseCount + ') 开始(同步代码开始)'); var p1 = new Promise( function(resolve, reject) &#123; log.insertAdjacentHTML('beforeend', thisPromiseCount + ') Promise开始(异步代码开始)'); window.setTimeout(function() &#123; resolve(thisPromiseCount); &#125;, Math.random() * 2000 + 1000); &#125; ); p1.then( function(val) &#123; log.insertAdjacentHTML('beforeend', val + ') Promise被满足了(异步代码结束)'); &#125; ); log.insertAdjacentHTML('beforeend', thisPromiseCount + ') 建立了Promise(同步代码结束)'); &#125; document.querySelector('button').addEventListener('click', testPromise); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 效果： 结语通过一份简易的实现代码，理解Promise 原理还是挺容易的。全部代码 ！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[MongoDB基本命令]]></title>
      <url>%2F2016%2F12%2F22%2FMongoDB%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4%2F</url>
      <content type="text"><![CDATA[安装与启动下载Mongodb成功安装并启动MongoDB后，再打开一个命令行窗口进入mongodb安装目录bin文件夹下输入mongo，就可以进行数据库的一些操作。 基本命令输入help可以看到基本操作命令：show dbs 显示数据库列表show collections 显示当前数据库中的集合（类似关系数据库中的表）show users 显示用户use &lt;db name&gt; 切换当前数据库，这和MS-SQL里面的意思一样db.help() 显示数据库操作命令，里面有很多的命令db.foo.help() 显示集合操作命令，同样有很多的命令，foo指的是当前数据库下，一个叫foo的集合，并非真正意义上的命令db.foo.find() 对于当前数据库中的foo集合进行数据查找（由于没有条件，会列出所有数据）db.foo.find( { a : 1 } ) 对于当前数据库中的foo集合进行查找，条件是数据中有一个属性叫a，且a的值为1MongoDB没有创建数据库的命令，但有类似的命令。如：如果你想创建一个myTest的数据库，先运行use myTest命令，之后就做一些操作（如：db.createCollection(&#39;user&#39;)）,这样就可以创建一个名叫myTest的数据库。 常用命令Help查看命令提示12345help db.help(); db.yourColl.help(); db.youColl.find().help(); rs.help(); 切换/创建数据库1use yourDB; 当创建一个集合(table)的时候会自动创建当前数据库 查询所有数据库1show dbs; 删除当前使用数据库1db.dropDatabase(); 从指定主机上克隆数据库1db.cloneDatabase(&quot;127.0.0.1&quot;); 将指定机器上的数据库的数据克隆到当前数据库 从指定的机器上复制指定数据库数据到某个数据库1db.copyDatabase("mydb", "temp", "127.0.0.1");将本机的mydb的数据复制到temp数据库中 修复当前数据库1db.repairDatabase(); 查看当前使用的数据库12db.getName();db; db和getName方法是一样的效果，都可以查询当前使用的数据库 显示当前db状态1db.stats(); 当前db版本1db.version(); 查看当前db的链接机器地址1db.getMongo(); Collection集合创建一个聚集集合（table）1db.createCollection(&quot;collName&quot;, &#123;size: 20, capped: 5, max: 100&#125;); 得到指定名称的聚集集合（table）1db.getCollection(&quot;account&quot;); 得到当前db的所有聚集集合1db.getCollectionNames(); 显示当前db所有聚集索引的状态1db.printCollectionStats(); 用户相关添加一个用户12db.addUser(&quot;name&quot;);db.addUser(&quot;userName&quot;, &quot;pwd123&quot;, true); 添加用户、设置密码、是否只读 数据库认证、安全模式1db.auth(&quot;userName&quot;, &quot;123123&quot;); 显示当前所有用户1show users; 删除用户1db.removeUser(&quot;userName&quot;); 其他查询之前的错误信息1db.getPrevError(); 清除错误记录1db.resetError(); 查看集合基本信息1、查看帮助 db.yourColl.help();2、查询当前集合的数据条数 db.yourColl.count();3、查看数据空间大小 db.userInfo.dataSize();4、得到当前聚集集合所在的db db.userInfo.getDB();5、得到当前聚集的状态 db.userInfo.stats();6、得到聚集集合总大小 db.userInfo.totalSize();7、聚集集合储存空间大小 db.userInfo.storageSize();8、Shard版本信息 db.userInfo.getShardVersion()9、聚集集合重命名 db.userInfo.renameCollection(&quot;users&quot;); 将userInfo重命名为users10、删除当前聚集集合 db.userInfo.drop(); 集合查询查询所有记录1db.userInfo.find(); 相当于：select* from userInfo;默认每页显示20条记录，当显示不下的情况下，可以用it迭代命令查询下一页数据。注意：键入it命令不能带“；”但是你可以设置每页显示数据的大小，用DBQuery.shellBatchSize= 50;这样每页就显示50条记录了。 查询去掉后的当前聚集集合中的某列的重复数据1db.userInfo.distinct(&quot;name&quot;); 会过滤掉name中的相同数据相当于：select distict name from userInfo; 查询age = 22的记录1db.userInfo.find(&#123;&quot;age&quot;: 22&#125;); 相当于： select * from userInfo where age = 22; 查询age &gt; 22的记录1db.userInfo.find(&#123;age: &#123;$gt: 22&#125;&#125;); 相当于：select * from userInfo where age &gt;22; 查询age &lt; 22的记录1db.userInfo.find(&#123;age: &#123;$lt: 22&#125;&#125;); 相当于：select * from userInfo where age &lt;22; 查询age &gt;= 25的记录1db.userInfo.find(&#123;age: &#123;$gte: 25&#125;&#125;); 相当于：select * from userInfo where age &gt;= 25; 查询age &lt;= 25的记录1db.userInfo.find(&#123;age: &#123;$lte: 25&#125;&#125;); 查询age &gt;= 23 并且 age &lt;= 261db.userInfo.find(&#123;age: &#123;$gte: 23, $lte: 26&#125;&#125;); 查询name中包含 mongo的数据1db.userInfo.find(&#123;name: /mongo/&#125;); 相当于:select * from userInfo where name like ‘%mongo%’; 查询name中以mongo开头的1db.userInfo.find(&#123;name: /^mongo/&#125;); 相当于：select * from userInfo where name like ‘mongo%’; 查询指定列name、age数据1db.userInfo.find(&#123;&#125;, &#123;name: 1, age: 1&#125;); 相当于：select name, age from userInfo;当然name也可以用true或false,当用ture的情况下河name:1效果一样，如果用false就是排除name，显示name以外的列信息。 查询指定列name、age数据, age &gt; 251db.userInfo.find(&#123;age: &#123;$gt: 25&#125;&#125;, &#123;name: 1, age: 1&#125;); 相当于：select name, age from userInfo where age &gt;25; 按照年龄排序12升序：db.userInfo.find().sort(&#123;age: 1&#125;);降序：db.userInfo.find().sort(&#123;age: -1&#125;); 查询name = zhangsan, age = 22的数据1db.userInfo.find(&#123;name: &apos;zhangsan&apos;, age: 22&#125;); 相当于：select * from userInfo where name = ‘zhangsan’ and age = ‘22’; 查询前5条数据1db.userInfo.find().limit(5); 相当于：selecttop 5 * from userInfo; 查询10条以后的数据1db.userInfo.find().skip(10); 相当于：select from userInfo where id not in (selecttop 10 from userInfo); 查询在5-10之间的数据1db.userInfo.find().limit(10).skip(5); 可用于分页，limit是pageSize，skip是第几页*pageSize or与 查询1db.userInfo.find(&#123;$or: [&#123;age: 22&#125;, &#123;age: 25&#125;]&#125;); 相当于：select * from userInfo where age = 22 or age = 25; 查询第一条数据1db.userInfo.findOne(); 相当于：selecttop 1 * from userInfo;db.userInfo.find().limit(1); 查询某个结果集的记录条数1db.userInfo.find(&#123;age: &#123;$gte: 25&#125;&#125;).count(); 相当于：select count(*) from userInfo where age &gt;= 20; 按照某列进行排序1db.userInfo.find(&#123;sex: &#123;$exists: true&#125;&#125;).count(); 相当于：select count(sex) from userInfo; 索引创建索引12db.userInfo.ensureIndex(&#123;name: 1&#125;);db.userInfo.ensureIndex(&#123;name: 1, ts: -1&#125;); 查询当前聚集集合所有索引1db.userInfo.getIndexes(); 查看总索引记录大小1db.userInfo.totalIndexSize(); 读取当前集合的所有index信息1db.users.reIndex(); 删除指定索引1db.users.dropIndex(&quot;name_1&quot;); 删除所有索引索引1db.users.dropIndexes(); 修改、添加、删除集合数据添加1db.users.save(&#123;name: ‘zhangsan’, age: 25, sex: true&#125;); 添加的数据的数据列，没有固定，根据添加的数据为准 修改1db.users.update(&#123;age: 25&#125;, &#123;$set: &#123;name: &apos;changeName&apos;&#125;&#125;, false, true); 相当于：update users set name = ‘changeName’ where age = 25;1db.users.update(&#123;name: &apos;Lisi&apos;&#125;, &#123;$inc: &#123;age: 50&#125;&#125;, false, true); 相当于：update users set age = age + 50 where name = ‘Lisi’;1db.users.update(&#123;name: &apos;Lisi&apos;&#125;, &#123;$inc: &#123;age: 50&#125;, $set: &#123;name: &apos;hoho&apos;&#125;&#125;, false, true); 相当于：update users set age = age + 50, name = ‘hoho’ where name = ‘Lisi’; 删除1db.users.remove(&#123;age: 132&#125;); 查询修改删除12345678910111213db.users.findAndModify(&#123; query: &#123;age: &#123;$gte: 25&#125;&#125;, sort: &#123;age: -1&#125;, update: &#123;$set: &#123;name: &apos;a2&apos;&#125;, $inc: &#123;age: 2&#125;&#125;, remove: true&#125;); db.runCommand(&#123; findandmodify : &quot;users&quot;, query: &#123;age: &#123;$gte: 25&#125;&#125;, sort: &#123;age: -1&#125;, update: &#123;$set: &#123;name: &apos;a2&apos;&#125;, $inc: &#123;age: 2&#125;&#125;, remove: true&#125;); update 或 remove 其中一个是必须的参数; 其他参数可选。 参数 详解 默认值 query 查询过滤条件 {} sort 如果多个文档符合查询过滤条件，将以该参数指定的排列方式选择出排在首位的对象，该对象将被操作 {} remove 若为true，被选中对象将在返回前被删除 N/A update 一个 修改器对象 N/A new 若为true，将返回修改后的对象而不是原始对象。在删除操作中，该参数被忽略。 false fields 参见Retrieving a Subset of Fields (1.5.0+) All fields upsert 创建新对象若查询结果为空。 示例 (1.5.4+) false 语句块操作简单Hello World1print(&quot;Hello World!&quot;); 这种写法调用了print函数，和直接写入”Hello World!”的效果是一样的； 将一个对象转换成json12tojson(new Object());tojson(new Object(&apos;a&apos;)); 循环添加数据123for (var i = 0; i &lt; 30; i++) &#123; db.users.save(&#123;name: &quot;u_&quot; + i, age: 22 + i, sex: i % 2&#125;);&#125;; 这样就循环添加了30条数据，同样也可以省略括号的写法1for (var i = 0; i &lt; 30; i++) db.users.save(&#123;name: &quot;u_&quot; + i, age: 22 + i, sex: i % 2&#125;); 也是可以的，当你用db.users.find()查询的时候，显示多条数据而无法一页显示的情况下，可以用it查看下一页的信息； find 游标查询1234var cursor = db.users.find();while (cursor.hasNext()) &#123; printjson(cursor.next()); &#125; 这样就查询所有的users信息，同样可以这样写12var cursor = db.users.find();while (cursor.hasNext()) &#123; printjson(cursor.next); &#125; 同样可以省略{}号 forEach迭代循环1db.users.find().forEach(printjson); forEach中必须传递一个函数来处理每条迭代的数据信息 将find游标当数组处理12var cursor = db.users.find();cursor[4]; //取得下标索引为4的那条数据 既然可以当做数组处理，那么就可以获得它的长度：cursor.length();或者cursor.count();那样我们也可以用循环显示数据1for (var i = 0, len = c.length(); i &lt; len; i++) printjson(c[i]); 将find游标转换成数组12var arr = db.users.find().toArray();//用toArray方法将其转换为数组printjson(arr[2]); 定制我们自己的查询结果只显示age &lt;= 28的并且只显示age这列数据1234db.users.find(&#123;age: &#123;$lte: 28&#125;&#125;, &#123;age: 1&#125;).forEach(printjson);db.users.find(&#123;age: &#123;$lte: 28&#125;&#125;, &#123;age: true&#125;).forEach(printjson);//排除age的列db.users.find(&#123;age: &#123;$lte: 28&#125;&#125;, &#123;age: false&#125;).forEach(printjson); forEach传递函数显示信息1db.things.find(&#123;x:4&#125;).forEach(function(x) &#123;print(tojson(x));&#125;);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[实时通讯之Socket.io]]></title>
      <url>%2F2016%2F12%2F22%2F%E5%AE%9E%E6%97%B6%E9%80%9A%E8%AE%AF%E4%B9%8BSocket-io%2F</url>
      <content type="text"><![CDATA[WebSocketWebSocket是HTML5开始提供的一种浏览器与服务器间进行全双工通讯的网络技术。使用 WebSocket ，浏览器和服务器只需要要做一个握手的动作，然后，浏览器和服务器之间就形成了一条快速通道，两者之间就直接可以数据互相传送。而且它为我们实现即时服务带来了两大好处： 节省资源：互相沟通的Header是很小的-大概只有 2 Bytes。 推送信息：不需要客户端请求，服务器可以主动传送数据给客户端。 Socket.ioSocket.IO是一个WebSocket库，包括了客户端的js和服务器端的nodejs，它的目标是构建可以在不同浏览器和移动设备上使用的实时应用。 服务监听socket.io的服务端启动非常的简单，引用socket.io模块。然后调用listen函数，传入监听的端口号，开始服务监听。1var io = require('socket.io')(80); 注册事件connection事件在客户端成功连接到服务端时触发，有了这个事件，我们可以随时掌握用户连接到服务端的信息。当客户端成功建立连接时，在connection事件的回调函数中，我们还是可以为socket注册一些常用的事件,如：disconnect事件，它在客户端连接断开时触发，这时候我就知道用户已经离开了。1234567var io = require('socket.io')(80);io.on('connection',function(socket)&#123; //连接成功... socket.on('disconnect',function()&#123; //用户已经离开... &#125;);&#125;); 启动服务为了在浏览器中能够访问到我们的服务，我们还需要在服务端搭建一个简单的web服务器，让浏览器能够访问我们的客户端页面。为了便捷，我们选用node.js中常用的express框架来实现web服务，示例如下：1234567891011var express = require('express');var app = express();app.get('/',function(req,res)&#123; res.status(200).send('欢迎！');&#125;);var server = require('http').createServer(app);var io = require('socket.io')(server);io.on('connection',function(socket)&#123; //do something&#125;);server.listen(80); 客户端引用服务端运行后会在根目录动态生成socket.io的客户端js文件，客户端可以通过固定路径/socket.io/socket.io.js添加引用。首先添加网页index.html,并在网页中引用客户端js文件：1&lt;script src="/socket.io/socket.io.js"&gt;&lt;/script&gt; 当然这样的客户端引用方式并不是必须的，我们也可以引用官方的cdn或者下载到本地的客户端文件。一般情况下推荐引用动态生成的客户端文件，因为这样客户端和服务端的版本可以保持一致，减少出错的几率。1&lt;script src="https://cdn.socket.io/socket.io-1.2.1.js"&gt;&lt;/script&gt; 连接服务当客户端成功加载socket.io客户端文件后会获取到一个全局对象io，我们将通过io.connect函数来向服务端发起连接请求。1234567var socket = io.connect('/');socket.on('connect',function()&#123; //连接成功&#125;);socket.on('disconnect',function(data)&#123; //连接断开&#125;); connect函数可以接受一个url参数，url可以socket服务的http完整地址，也可以是相对路径，如果省略则表示默认连接当前路径。与服务端类似，客户端也需要注册相应的事件来捕获信息，不同的是客户端连接成功的事件是connect。 实时通讯当我们成功建立连接后，我们可以通过socket对象的send函数来互相发送消息，示例-客户端向服务端发送消息(index.html)：12345678var socket = io.connect('/');socket.on('connect',function()&#123; //客户端连接成功后发送消息'hello world!' socket.send('hello world!');&#125;);socket.on('message',function(data)&#123; alert(data);&#125;); 连接成功后，我们向服务端发送消息hello world!，还为socket注册了message事件，它是send函数对应的接收消息的事件，当服务端向客户端send消息时，我们就可以在message事件中接收到发送过来的消息。服务端向客户端发送消息也可以通过send的方式，示例 - 服务端向客户端发送消息(app.js)：12345678var io = require('scoket.io');io.on('connection',function(socket)&#123; socket.send('欢迎！'); socket.on('message',function(data)&#123; //收到消息 console.log(data); &#125;);&#125;); 与客户端相同，服务端也需要为socket注册message事件来接收客户端发送过来的消息。 发送信息socket.io既然是用来实现通讯的，那么如何发送、接收信息才是根本。在socket.io中，emit函数用于发送数据，还上述讲解中，我们使用send的方式实现了信息的互发，其实send函数只是emit的封装，实际上还是使用了emit，且看send函数是如何实现的：123456function send()&#123; var args = toArray(arguments); args.unshift('message'); this.emit.apply(this, args); return this;&#125; 在send函数中，获取到原来的参数，并在原来的基础上插入了一个参数message，然后调用了emit函数。通过send函数的实现，我们也学会了emit函数的用法，它有两个参数，第一个参数是事件名称，在接收端注册该事件就可以接收到发送过去的信息，事件名称可以自由定义，在不同的场景下，我们可以定义不同的事件来接收消息。第二个参数才是发送的数据。了解清楚了工作原理，下面来将send替换成emit函数发送信息：123456//app.jsio.on('connection',function(socket)&#123; socket.emit('message','连接成功！'); socket.on('message',function(data)&#123; &#125;);&#125;); 服务端事件事件监听是实现通讯的基础。在一些关键的的状态下，socket.io可以注册相应的事件，通过事件监听，我们可以在这些事件中作出反应，常用的事件如下： 事件 描述 connection 客户端成功连接到服务器。 message 捕获客户端send信息。 disconnect 客户端断开连接。 error 发生错误。 客户端事件较服务端而言，客户端提供更多的监听事件，在实时应用中，我们可以为这些事件注册监听并作出反应。 事件 描述 connect 成功连接到服务器。 connecting 正在连接。 disconnect 断开连接。 connect_failed 连接失败。 error 连接错误。 message 监听服务端send的信息。 reconnect_failed 重新连接失败。 reconnect 重新连接成功。 reconnecting 正在重连。 那么客户端socket发起连接时的顺序是怎么样的呢？当第一次连接时，事件触发顺序为：connecting → connect当失去连接时，事件触发顺序为：disconnect → reconnecting →connecting → reconnect → connect 命名空间命名空间着实是一个非常实用好用的功能。我们可以通过命名空间，划分出不同的房间，在房间里的广播和通信都不会影响到房间以外的客户端。在服务端，通过of(&quot;&quot;)的方式来划分新的命名空间：12io.of('chat').on('connection',function(socket)&#123;&#125;); 示例中，我们创建一个名为chat的房间，客户端可以通过如下方式连接到指定的房间：1var socket = io.connect('/chat'); 虽然连接到指定的房间，但是我们也可以在服务端操作，自由的进出房间：12socket.join('chat');//进入chat房间socket.leave('chat');//离开chat房间 广播消息在实时应用中，广播是一个不可或缺的功能，socket.io提供两种服务端广播方式。第一种广播方式可以称之为’全局广播’，顾名思义，全局广播就是所有连接到服务器的客户端都会受到广播的信息：1socket.broadcast.emit('DATA',data); 但是，在实际应用场景中，我们很多时候并不需要所有用户都收到广播信息，有的广播信息只发送给一部分客户端，比如某个房间里面的用户，那么可以使用如下方式：1socket.broadcast.to('chat').emit('DATA',data); 当使用to()的方式广播信息时，只有该命名空间下的客户端才会收到广播信息，是不是很方便呢。 传递参数在很多应用场景中，客户端发起连接请求时都需要传递参数，这些参数可能是身份验证、初始化设置等等，那么socket.io发起连接时如何传递参数呢？1var socket = io.connect('/'); 由于connect函数发起连接的参数是一个url，你可能会想到把参数拼接到url上，如http://xxxx?xx=xxxx，但是很遗憾这样是行不通的，我们可以通过这样的方式来传递参数：1var socket = io.connect('/',&#123; _query:'sid=123456' &#125;); 在服务端可以这样获取到传递的参数:1234io.use(function(socket)&#123; var query = socket.request._query; var sid = query.sid; &#125;); 客户端传递的参数已经被解析成了一个json对象，这个对象就是_query。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[模块module.exports与实例化方法]]></title>
      <url>%2F2016%2F12%2F21%2F%E6%A8%A1%E5%9D%97module-exports%E4%B8%8E%E5%AE%9E%E4%BE%8B%E5%8C%96%E6%96%B9%E6%B3%95%2F</url>
      <content type="text"><![CDATA[在nodejs中，提供了exports 和 require 两个对象，其中 exports 是模块公开的接口，require 用于从外部获取一个模块的接口，即所获取模块的 exports 对象。而在exports抛出的接口中，如果你希望你的模块就想为一个特别的对象类型，请使用module.exports；如果希望模块成为一个传统的模块实例，请使用exports.xx方法；module.exports才是真正的接口，exports只不过是它的一个辅助工具。最终返回给调用的是module.exports而不是exports。下面看代码；首先来看module.exports，新建一个hello.js，代码如下： 12345678module.exports=function(name,age,money)&#123; this.name=name; this.age=age; this.money=money; this.say=function()&#123; console.log('我的名字叫：'+this.name+'，我今年'+this.age+'岁，月薪为：'+this.money+'元；') &#125;&#125;; 可以看到，module.exports被赋予了一个构造函数；再新建一个main.js，其中引入hello.js这个模块，把exports方法接受进来，main.js代码如下： 123var Hello=require('./hello');var hello=new Hello('jone','24','10000')hello.say(); 进入node环境，运行main.js，可以看到，已经打印出来：我的名字叫：jone，我今年24岁，月薪为：10000元；而在hello.js中，我们是赋予了exports一个函数 ，当然，也可以采用匿名函数的方式；见代码：123456789function hello(name,age,money)&#123; this.name=name; this.age=age; this.money=money; this.say=function()&#123; console.log('我的名字叫：'+this.name+'，我今年'+this.age+'岁，月薪为：'+this.money+'元；') &#125;&#125;module.exports=hello; 以上module.exports，这个模块很明显是一个特别的对象模型；那如果采用对象实例的方法该如何实现呢？其实也很简单，只需要给exports对象赋值一个新的方法即可；见下面代码： 12345678910function hello(name,age,money)&#123; this.name=name; this.age=age; this.money=money; this.say=function()&#123; console.log('我的名字叫：'+this.name+'，我今年'+this.age+'岁，月薪为：'+this.money+'元；') &#125;&#125;var Hello=new hello('jone','24','10000');exports.add=Hello 在hello.js中，依然是一个构造函数，声明了一个变量Hello，然后再把Hello赋值给exports自定义的add方法；那么在main.js中，由于add已经是exports的一个自定义的实例方法了，因此我们可以直接这么调用它：Hello.add.say()；见代码：12var Hello=require(&apos;./hello&apos;);Hello.add.say() 进行node环境，运行main.js，可以看到，结果和上面一样，都会输出：我的名字叫：jone，我今年24岁，月薪为：10000元；]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[D3入门总结]]></title>
      <url>%2F2016%2F12%2F21%2FD3%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93%2F</url>
      <content type="text"><![CDATA[D3.js 是基于数据操作文档的 JavaScript 库，通过 HTML、SVG 和 CSS 赋予数据以生命。D3 集强力的可视化组件与数据驱动型的 DOM 操作手法于一身，能最大限度地引出现代浏览器的性能，而不必束缚于特定的框架。 基础选择元素1d3.select() 选择所有指定元素的第一个1d3.selectAll() 选择指定元素的全部 绑定元素1data() 绑定一个数组到选择集上，数组的各项值分别与选择集的各元素绑定1dataum() 绑定一个数据到选择集上1function(d, i)&#123; &#125; 当选择集需要使用被绑定的数据时，常需要使用匿名函数。其包含两个参数，其中：d 代表数据，也就是与某元素绑定的数据i 代表索引，代表数据的索引号，从 0 开始 插入元素1append() 在选择集末尾插入元素 1insert() 在选择集前面插入元素 删除元素1remove() 添加画布1234var svg = d3.select("body") //选择文档中的body元素 .append("svg") //添加一个svg元素 .attr("width", 300) //设定宽度 .attr("height", 300); //设定高度 绘制矩形12345var dataset = [ 250 , 210 , 170 , 130 , 90 ]; svg.selectAll("rect") //选择svg内所有的矩形 .data(dataset) //绑定数组 .enter() //指定选择集的enter部分 .append("rect") //添加足够数量的矩形元素 有数据，而没有足够图形元素的时候，使用此方法可以添加足够的元素。 矩形的属性，常用的有四个： x - 矩形左上角的 x 坐标 y - 矩形左上角的 y 坐标 width - 矩形的宽度 height - 矩形的高度 注意，在 SVG 中，x 轴的正方向是水平向右，y 轴的正方向是垂直向下的。 比例尺缩放1d3.scale.linear() 返回一个线性比例尺12domain()range() 设定比例尺的定义域和值域12d3.max()d3.min() 求数组的最大值和最小值 线性比例尺1234567891011var dataset = [1.2, 2.3, 0.9, 1.5, 3.3];var min = d3.min(dataset);var max = d3.max(dataset);var linear = d3.scale.linear() .domain([min, max]) .range([0, 300]); linear(0.9); //返回 0linear(2.3); //返回 175linear(3.3); //返回 300 上面的方法将dataset中最小的值，映射成0；将最大的值，映射成 300。 d3.scale.linear() 的返回值，是可以当做函数来使用的。因此，有这样的用法：linear(2.3)，返回175。 序数比例尺12345678910var index = [0, 1, 2, 3, 4];var color = ["red", "blue", "green", "yellow", "black"];var ordinal = d3.scale.ordinal() .domain(index) .range(color);ordinal(0); //返回 redordinal(2); //返回 greenordinal(4); //返回 black 定义坐标轴1d3.svg.axis() D3 中坐标轴的组件，能够在 SVG 中生成组成坐标轴的元素。 要生成坐标轴，需要用到比例尺，它们二者经常是一起使用的。12345678910var dataset = [ 2.5 , 2.1 , 1.7 , 1.3 , 0.9 ];//定义比例尺var linear = d3.scale.linear() .domain([0, d3.max(dataset)]) .range([0, 250]);//定义坐标轴var axis = d3.svg.axis() .scale(linear) //指定比例尺 .orient("bottom") //指定刻度的方向 .ticks(7); //指定刻度的数量 scale()：指定比例尺。 orient()：指定刻度的朝向，bottom 表示在坐标轴的下方显示。 ticks()：指定刻度的数量。 定义了坐标轴之后，只需要在 SVG 中添加一个分组元素 ，再将坐标轴的其他元素添加到这个 里即可1svg.append("g").call(axis); 在 D3 中，call() 的参数是一个函数,调用之后，将当前的选择集作为参数传递给此函数 完整的柱形图 添加 SVG 画布12345678var width = 400;var height = 400;var padding = &#123;left:30, right:30, top:20, bottom:20&#125;;//在 body 里添加一个 SVG 画布 var svg = d3.select("body") .append("svg") .attr("width", width) .attr("height", height); 定义数据和比例尺123456789var dataset = [10, 20, 30, 40, 33, 24, 12, 5];//x轴的比例尺var xScale = d3.scale.ordinal() .domain(d3.range(dataset.length)) .rangeRoundBands([0, width - padding.left - padding.right]);//y轴的比例尺var yScale = d3.scale.linear() .domain([0,d3.max(dataset)]) .range([height - padding.top - padding.bottom, 0]); 定义坐标轴123456789//定义x轴var xAxis = d3.svg.axis() .scale(xScale) .orient("bottom"); //定义y轴var yAxis = d3.svg.axis() .scale(yScale) .orient("left"); 添加矩形和文字元素12345678910111213141516171819202122232425262728293031323334353637383940414243//矩形之间的空白var rectPadding = 4;//添加矩形元素var rects = svg.selectAll(".MyRect") .data(dataset) .enter() .append("rect") .attr("class","MyRect") .attr("transform","translate(" + padding.left + "," + padding.top + ")") .attr("x", function(d,i)&#123; return xScale(i) + rectPadding/2; &#125; ) .attr("y",function(d)&#123; return yScale(d); &#125;) .attr("width", xScale.rangeBand() - rectPadding ) .attr("height", function(d)&#123; return height - padding.top - padding.bottom - yScale(d); &#125;);//添加文字元素var texts = svg.selectAll(".MyText") .data(dataset) .enter() .append("text") .attr("class","MyText") .attr("transform","translate(" + padding.left + "," + padding.top + ")") .attr("x", function(d,i)&#123; return xScale(i) + rectPadding/2; &#125; ) .attr("y",function(d)&#123; return yScale(d); &#125;) .attr("dx",function()&#123; return (xScale.rangeBand() - rectPadding)/2; &#125;) .attr("dy",function(d)&#123; return 20; &#125;) .text(function(d)&#123; return d; &#125;); 添加坐标轴的元素1234567891011//添加x轴svg.append("g") .attr("class","axis") .attr("transform","translate(" + padding.left + "," + (height - padding.bottom) + ")") .call(xAxis); //添加y轴svg.append("g") .attr("class","axis") .attr("transform","translate(" + padding.left + "," + padding.top + ")") .call(yAxis); 过渡效果1transition() 启动过渡效果。 其前后是图形变化前后的状态（形状、位置、颜色等等）1duration() 指定过渡的持续时间，单位为毫秒。1ease() 指定过渡的方式，常用的有： linear：普通的线性变化 circle：慢慢地到达变换的最终状态 elastic：带有弹跳的到达最终状态 bounce：在最终状态处弹跳几次1delay() 指定延迟的时间，表示一定时间后才开始转变，单位同样为毫秒。此函数可以对整体指定延迟，也可以对个别指定延迟。 Update、Enter、Exit如果数组为 [3, 6, 9, 12, 15]，将此数组绑定到3个 p 元素的选择集上。可以想象，会有两个数据没有元素与之对应，这时候 D3 会建立两个空的元素与数据对应，这一部分就称为 Enter。而有元素与数据对应的部分称为 Update。 如果数组为 [3]，则会有两个元素没有数据绑定，那么没有数据绑定的部分被称为 Exit。 update 部分的处理办法一般是：更新属性值 enter 部分的处理办法一般是：添加元素后，赋予属性值 exit 部分的处理办法一般是：删除元素（remove）]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[移动端手势库Hammer.js]]></title>
      <url>%2F2016%2F12%2F18%2F%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%89%8B%E5%8A%BF%E5%BA%93Hammer-js%2F</url>
      <content type="text"><![CDATA[Github Hammer.js是一个开源的，轻量级的javascript库，它可以在不需要依赖其他东西的情况下识别触摸，鼠标事件。 使用引入hammer.js到文件中，并创建一个新的实例：1234var hammer = new Hammer(Element, Options);hammer.on('tap', function(ev) &#123; console.log(ev);&#125;); hammerjs内置多种手势识别器，包括 tap：轻触，与click相比有300ms的延迟 doubletap：双点击 press：按住,最小按压时间为500毫秒 pan：拖动平移 panstart：拖动开始 panmove：拖动过程 panend：拖动结束 pancancel：拖动取消 panleft：向左拖动 panright：向右拖动 panup：向上拖动 pandown：向下拖动 swipe：快速滑动 swipeleft：向左滑动 swiperight：向右滑动 swipeup：向上滑动 swipedown：向下滑动 pinch：多触点捏放 pinchstart：多点触控开始 pinchmove：多点触控过程 pinchend：多点触控结束 pinchcancel：多点触控取消 pinchin：多点触控时两手指距离越来越近 pinchout：多点触控时两手指距离越来越远 rotate：旋转识别器 rotatestart：旋转开始 rotatemove：旋转过程 rotateend：旋转结束 rotatecancel：旋转取消 其中 pinch 和 rotate 默认是不可用的，想启用它们，需要加上： 12hammer.get('pinch').set(&#123; enable: true &#125;);hammer.get('rotate').set(&#123; enable: true &#125;); pan 和 swipe默认只识别水平方位的手势，若要允许识别器识别垂直方位或全部方位的 pan 和 swipe，可以这么写： 12hammer.get('pan').set(&#123; direction: Hammer.DIRECTION_ALL &#125;);hammer.get('swipe').set(&#123; direction: Hammer.DIRECTION_VERTICAL &#125;); 另建议加上如下meta标签，防止doubletap 或 pinch 缩放了viewport： 1&lt;meta name="viewport" content="user-scalable=no, width=device-width, initial-scale=1, maximum-scale=1"&gt; 事件对象 每一个Hammer触发的事件都会收到一个包含了如下属性的事件对象： on(events, handler) 和 .off(events, [handler]) 监听由被添加的识别器触发的事件，或者移除那些绑定了的事件。参数中将事件通过空格隔开可处理多个事件 在jQuery基础上使用123456$("#element").hammer(&#123; // 对DOM进行一些初始化，这里可以加入一些参数 &#125;) .on("tap", function(ev) &#123; console.log(ev); &#125;);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hexo博客命令]]></title>
      <url>%2F2016%2F12%2F18%2Fhello-world%2F</url>
      <content type="text"><![CDATA[写在第一页，作为建立个人博客的第一篇文章，使用Hexo搭建，记录日常使用的常用命令。本博客使用品Next主题。精于心，简于形 快速开始创建新文章1$ hexo new post "My New Post" 创建新页面1$ hexo new page "My New Page" 更多信息 启动服务器1$ hexo server 更多信息 生成静态文件1$ hexo generate 更多信息 发布到远程服务器1$ hexo deploy 更多信息]]></content>
    </entry>

    
  
  
</search>
