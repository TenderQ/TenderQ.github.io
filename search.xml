<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[Angular路由Ui-Router详解]]></title>
      <url>%2F2017%2F04%2F14%2FAngular%E8%B7%AF%E7%94%B1Ui-Router%E8%AF%A6%E8%A7%A3%2F</url>
      <content type="text"><![CDATA[UI-RouterUI-Router是Angular第三方开发用于管理UI与路由的模块，功能比Angular原生的ng-Route要强而且全，因此原生基本已经被其替代。 UI-Router是采用的是一种状态管理机制，“状态”可以继承，“状态”不禁包含url，还有views,controller等，以此来组织路由和控制界面UI的渲染，而不是单纯的改变路由。对于UI方面提供嵌套视图，可以一个页面嵌套多个视图，多视图再嵌套单个视图，每个视图可提供其特定的controller等针对管理，方便视图重用且功能精细，可以打造十分复杂的web应用。 基本使用导入模块angular-ui-router.js,可以通过bower包管理器或github等下载。1&lt;script src=&quot;angular-ui-router/release/angular-ui-router.js&quot;&gt;&lt;/script&gt; 然后在ngApp中加入ui.router1var app = angular.module('myApp', ['ui.router']); 然后再创建login.html用于嵌套，再在需要嵌套的页面配置12// index.html url'/'&lt;div ui-view&gt;&lt;/div&gt; 再配置路由12345678app.config(function($stateProvider, $urlRouterProvider) &#123; $urlRouterProvider.otherwise('/'); $stateProvider .state('login', &#123; url: '/', templateUrl: 'login.html', &#125;);&#125;); 当进入主页它便自动将login.html嵌套到ui-view中。 指令ui-viewui-view是用来告诉ui-router哪里需要嵌套模板,视图可以未命名或命名。在任何模板（或根html）中只能有一个未命名的视图。123&lt;div ui-view&gt;&lt;/div&gt;&lt;div ui-view="chart"&gt;&lt;/div&gt; &lt;div ui-view="data"&gt;&lt;/div&gt; 在同一模板中具有多个视图时可以如下设置12345678910111213$stateProvider.state(&quot;home&quot;, &#123; views: &#123; &quot;&quot;: &#123; template: &quot;&lt;h1&gt;HELLO!&lt;/h1&gt;&quot; &#125;, &quot;chart&quot;: &#123; template: &quot;&lt;chart_thing/&gt;&quot; &#125;, &quot;data&quot;: &#123; templateUrl: &apos;tplUrl.html&apos; &#125; &#125; &#125;) autoscroll在ui-view元素指令上使用的属性指令。它允许在填充视图时设置浏览器窗口的滚动行为。默认情况下，$anchorScroll被ui-router的自定义滚动服务$uiViewScroll覆盖。1&lt;ui-view autoscroll[='expression']/&gt; 添加autoscroll属性到ui-view元素。（可选）使用表达式设置滚动是打开还是关闭。 ui-sref绑定在&lt;a&gt;标签，用于状态转换，类似&lt;a&gt;的href属性。如果状态具有关联的URL，底层通过$state.href()方法自动生成和更新属性。 用法 ui-sref=’stateName’ ui-sref=’stateName({param: value, param: value})’ 例子1234567&lt;a ui-sref="home"&gt;Home&lt;/a&gt; | &lt;a ui-sref="about"&gt;About&lt;/a&gt;&lt;ul&gt; &lt;li ng-repeat="contact in contacts"&gt; &lt;a ui-sref="contacts.detail(&#123; id: contact.id &#125;)"&gt;&#123;&#123; contact.name &#125;&#125;&lt;/a&gt; &lt;/li&gt;&lt;/ul&gt; 生成后的HTML12345678910111213&lt;a href="#/home" ui-sref="home"&gt;Home&lt;/a&gt; | &lt;a href="#/about" ui-sref="about"&gt;About&lt;/a&gt;&lt;ul&gt; &lt;li ng-repeat="contact in contacts"&gt; &lt;a href="#/contacts/1" ui-sref="contacts.detail(&#123; id: contact.id &#125;)"&gt;Joe&lt;/a&gt; &lt;/li&gt; &lt;li ng-repeat="contact in contacts"&gt; &lt;a href="#/contacts/2" ui-sref="contacts.detail(&#123; id: contact.id &#125;)"&gt;Alice&lt;/a&gt; &lt;/li&gt; &lt;li ng-repeat="contact in contacts"&gt; &lt;a href="#/contacts/3" ui-sref="contacts.detail(&#123; id: contact.id &#125;)"&gt;Bob&lt;/a&gt; &lt;/li&gt;&lt;/ul&gt; ui-sref-active与ui-sref一起使用的指令，在相关ui-sref指令的状态为活动时向元素添加类，并在非活动时删除它们。主要用例是通过使“活动”状态的菜单按钮显示不同，将其与非活动菜单项区分开，来简化依赖于ui-sref的导航菜单的特殊外观。 用法ui-sref-active=&apos;class1 class2 class3&apos; // 当相关ui-sref的状态为活动时，将类“class1”，“class2”和“class3”分别添加到指令元素，并且当其不活动时将其删除。 例子123456&lt;ul&gt; &lt;li ui-sref-active="active" class="item"&gt; &lt;a href ui-sref="app.user(&#123;user: 'zhangsan'&#125;)"&gt;@zhangsan&lt;/a&gt; &lt;/li&gt; &lt;!-- ... --&gt;&lt;/ul&gt; 当应用程序状态为“app.user”，并包含值为“zhangsan”的状态参数“user”时，生成的HTML将显示为123456&lt;ul&gt; &lt;li ui-sref-active=&quot;active&quot; class=&quot;item active&quot;&gt; &lt;a ui-sref=&quot;app.user(&#123;user: &apos;zhangsan&apos;&#125;)&quot; href=&quot;/users/zhangsan&quot;&gt;@zhangsan&lt;/a&gt; &lt;/li&gt; &lt;!-- ... --&gt;&lt;/ul&gt; $state$state.go()$state.go可以在JavaScript中转换状态（类似ui-sref在html中转换）。1$state.go(to,params,options) 参数 to是stateName，必须，使用”^”或”.”表示相对状态； params可空，类型是对象,挂载在对应$stateparams,参数也可以通过状态机制继承； options可空，类型是对象，字段包括： location:为boolean类型默认true,如果是true会更新地址中的url,flase不会，若为replace会更新并覆盖最后一此的记录。 inherit为boolean类型默认true,如果是true会继承最近的的url中的参数。 relative为对象默认$state.$current,当定义为相对路劲时，定义那个状态是相对的。 notify为boolean类型默认为true, 当为true时广播$stateChangeStart和$stateChangeSuccess事件 reload为boolean类型默认为false,如果是true会强制重载且一切一样。 $state.reload()强制重载当前状态，与$state.go的options内配制reload=true类似。1$state.reload(&apos;contact.detail&apos;); //强制刷新contact.detail状态 $state.includes(stateName[, params])$state.includes方法用于判断当前激活状态是否是指定的状态或者是指定状态的子状态，返回时boolean值.比如当前状态是contacts.details.item12345$state.includes("contacts"); // returns true$state.includes("contacts.details"); // returns true$state.includes("contacts.details.item"); // returns true$state.includes("contacts.list"); // returns false$state.includes("about"); // returns false params，假设当前状态contacts.details.item.edit，其url是/contacts/1/address/edit，为:id参数填充1,:item参数填充address。123$state.includes("contacts.detail", &#123;id: 1&#125;); // returns true$state.includes("contacts.detail.item", &#123;item:'address'&#125;); // returns true$state.includes("contacts", &#123;bogus:'gnarly'&#125;); // returns false $state.is(stateOrName[, params])类似$state.includes，但它比较严格。假设当前状态：contact.details.item123$state.is(&quot;contact.details.item&quot;); // returns true$state.is(contactDetailItemStateConfigObj); // returns true// 其他一切都会返回false params:12$state.is(&quot;contacts.detail.item.edit&quot;, &#123;id: 1, item: &apos;address&apos;&#125;); // returns true// 其他一切都会返回false $state.href(stateOrName [, params] [, options])一个URL生成方法，返回已经填充指定参数的状态的编译后的链接。 参数 stateOeName：string，你想要生成的url的状态或者状态对象。 params：object，一个用于填充状态需要的参数的对象。 options：可选配置对象。 lossy(当第一个参数url未被提供时是否继承导航的url进行构建href) inherit(是否继承当前url的参数) relative(当变化相对路径：如”^,定义的状态是相对的) absolute(是否生成绝对url)。1$state.href(&quot;about.person&quot;, &#123; person: &quot;bob&quot; &#125;) $state.get([stateName])通过将名称作为字符串传递来检索任何状态的配置对象的方法 $state.current返回状态对象的引用，用于访问自定义data, 关于$state在模板中使用 注意：使用$State和$stateparams需要将其挂载到$rootscope 1234angular.module("myApp").run(function ($rootScope, $state, $stateParams) &#123; $rootScope.$state = $state; $rootScope.$stateParams = $stateParams;&#125;); 现在，可以访问模板中的状态：1234&lt;ul class="nav"&gt; &lt;li ng-class="&#123; active: $state.includes('contacts') &#125;"&gt;&lt;a href="#/contacts"&gt;Contacts&lt;/a&gt;&lt;/li&gt; &lt;li ng-class="&#123; active: $state.includes('about') &#125;"&gt;&lt;a href="#/about"&gt;About&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt; $urlRouterProvider在UI-Router中，$urlRouterProvider负责监听$location.当$location变化的时候，$urlRouterProvider开始在一个规则的列表中一个个的查找，直到找到匹配的值。$urlRouterProvider用于在后端指定url的状态配置。所有的url被编译成UrlMatcher对象。 otherwise(rule)定义一个当请求的路径是无效路径时跳转的路径,处理无效路由。 rule：你想重定向的url路径或一个返回的网址路径的规则函数。函数传入两个参数：$injector和$location服务，而且必须返回一个string的url。 1234angular.module(&apos;Demo&apos;,[&apos;ui.router&apos;]) .config([&quot;$urlRouterProvider&quot;,function()&#123; $urlRouterProvider.otherwise(rule); // rule = 重定向的url&#125;]) rule(rule)定义使用$urlRouterProvider 来匹配指定的URL的规则。 rule：将$injector和$location作为arguments传入的处理函数。用来返回一个string类型的url路径。 12345678910angular.module('Demo',['ui.router']) .config(["$urlRouterProvider",function($urlRouterProvider)&#123; $urlRouterProvider.rule(function ($injector, $location) &#123; var path = $location.path(), normalized = path.toLowerCase(); if (path !== normalized) &#123; return normalized; &#125; &#125;); &#125;]) when(what,handler)为给定的URL匹配注册一个处理程序。 参数： what：需要重定向的传入路径，当前路径。 handler：需要重定向到的路径（或者是需要在路径被访问时运行的函数） handler是路径：1234567app.config(function($urlRouterProvider)&#123; // when there is an empty route, redirect to /index $urlRouterProvider.when('', '/index'); // You can also use regex for the match parameter $urlRouterProvider.when(/aspx/i, '/index');&#125;) handler是函数：12345678angular.module('Demo', ['ui.router']); .config(["$urlRouterProvider",function ($urlRouterProvider) &#123; $urlRouterProvider.when($state.url, function ($match, $stateParams) &#123; if ($state.$current.navigable !== state || !equalForKeys($match, $stateParams) &#123; $state.transitionTo(state, $match, false); &#125; &#125;); &#125;]); 如果提供一个函数处理，路由匹配的时候，这个函数就会被调用，它可以返回下列三种之一的结果。 false，这个回应告诉 $urlRouter 规则并不匹配，应该查找其它匹配的状态，在我们希望验证用户是否访问正确地址的时候很有用。 字符串，$urlRouter 将其作为重定向目标。 true 或者 undefined，函数已经处理了这个 url $stateProvider$stateProvider用于配制’状态’，可以是链式配制。12$stateProvider.state(stateName1, stateConfig1) .state(stateName2,stateConfig2); state(stateName,stateConfig);注册一个状态，并给定其配置。 参数 stateName是以个唯一的字符串，用于标记状态。 stateConfig用于管理状态的配制，object类型,配置具有以下各项属性： template： html模板字符串，或者一个返回html模板字符串的函数。 templateUrl：模板路径的字符串，或者返回模板路径字符串的函数。 templateProvider：function，返回html模板字符串或模板路径的服务。 controller：string/function，新注册一个控制器函数或者一个已注册的控制器的名称字符串。 controllerProvider：function，返回控制器或者控制器名称的服务 controllerAs：string，控制器别名。 parent：string/object，手动指定该状态的父级。 resolve：object，将会被注入controller去执行的函数，形式。它为状态的控制器提供了所需的依赖.这些依赖可以给状态对应的控制器提供所需要的内容或数据. url：string，当前状态的对应url。 views：object，视图展示的配置。形式。 abstract：boolean，一个永远不会被激活的抽象的状态，但可以给其子级提供特性的继承。默认是true。 onEnter：function，当进入一个状态后的回调函数。 onExit：function，当退出一个状态后的回调函数。 reloadOnSearch：boolean，如果为false，那么当一个search/query参数改变时不会触发相同的状态，用于当你修改$location.search()的时候不想重新加载页面。默认为true。 data：object，任意对象数据，用于自定义配置。继承父级状态的data属性。换句话说，通过原型继承可以达到添加一个data数据从而整个树结构都能获取到。 params：url里的参数值，通过它可以实现页面间的参数传递。 decorator(name,func);通过内部的$stateProvider以扩展或者重写状态生成器。可用于添加ui-router的自定义功能，例如，基于状态名称推断templateUrl。 警告：因为生成器的函数执行顺序的不确定，decorator不应该相互依赖。 参数： name：需要修改的生成函数名称。 func：可选，负责修改生成器函数的函数。 1234567891011121314151617$stateProvider.decorator('views', function (state, parent) &#123; var result = &#123;&#125;, views = parent(state); angular.forEach(views, function (config, name) &#123; var autoName = (state.name + '.' + name).replace('.', '/'); config.templateUrl = config.templateUrl || '/partials/' + autoName + '.html'; result[name] = config; &#125;); return result;&#125;);$stateProvider.state('home', &#123; views: &#123; 'contact.list': &#123; controller: 'ListController' &#125;, 'contact.item': &#123; controller: 'ItemController' &#125; &#125;&#125;);$state.go('home'); 以上代码修饰了views直接通过state的名称绑定完对应的页面模板。 事件状态更改事件所有这些事件都从广播$rootScope。 $stateChangeSuccess - 一旦状态转换完成就触发。 $stateChangeStart - 当转换开始时触发。 $stateNotFound - 当无法通过其名称找到状态时触发。 $stateChangeError - 在转换期间发生错误时触发。 视图加载事件 $viewContentLoading - 当视图开始加载时（在渲染DOM之前）每个视图触发一次。广播从$rootScope。 $viewContentLoaded - 当视图加载时（在渲染DOM之后）每个视图触发一次。从视图发出$scope。 事件触发执行顺序下面来理一下一个状态被激活的过程是怎样的: 触发$stateChangeStart事件,如果使用event.preventDefault(),会阻止状态改变. 如果没有找到对应状态,会触发$stateNotFound事件,然后中断. 触发$viewContentLoading事件. 如果在切换状态的过程中出错(比如resolve出错),触发$stateChangeError事件,无出错跳过此步. 触发上一个状态(若有)的onExit回调事件 触发当前状态的onEnter回调事件 触发$stateChangeSuccess事件 触发$viewContentLoaded事件 ui-router的单视图：123456789101112131415161718192021222324252627282930313233343536&lt;div ng-app="Demo" ng-controller="testCtrl as ctrl"&gt; &lt;ol&gt; &lt;li&gt;&lt;a ui-sref="app"&gt;app&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a ui-sref="test"&gt;test&lt;/a&gt;&lt;/li&gt; &lt;/ol&gt; &lt;div ui-view&gt;&lt;/div&gt;&lt;/div&gt;&lt;script type="text/ng-template" id="'page1.html'"&gt; this is page 1 for app.&lt;/script&gt;&lt;script type="text/ng-template" id="'page3.html'"&gt; this is page 1 for test.&lt;/script&gt;angular.module('Demo', ['ui.router']).config(["$stateProvider","$urlRouterProvider",routeConfig]).controller("testCtrl", angular.noop)function routeConfig($stateProvider,$urlRouterProvider)&#123; $urlRouterProvider.otherwise("/app"); $stateProvider .state("app",&#123; url:"/app", views:&#123; "":&#123; templateUrl:"'page1.html'" &#125; &#125; &#125;) .state("test",&#123; url:"/test", views:&#123; "":&#123; templateUrl:"'page3.html'" &#125; &#125; &#125;)&#125; ui-router的t多视图：1234567891011121314151617181920212223242526272829303132333435&lt;div ng-app="Demo" ng-controller="testCtrl as ctrl"&gt; &lt;ol&gt; &lt;li&gt;&lt;a ui-sref="app.page1"&gt;app&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a ui-sref="test.page1(&#123;id:1&#125;)"&gt;test&lt;/a&gt;&lt;/li&gt; &lt;/ol&gt; &lt;div ui-view&gt;&lt;/div&gt;&lt;/div&gt; &lt;script type="text/ng-template" id="'layout.html'"&gt; &lt;div ui-view="nav@"&gt;&lt;/div&gt; &lt;div ui-view&gt;&lt;/div&gt; &lt;/script&gt; &lt;script type="text/ng-template" id="'nav1.html'"&gt; &lt;ol&gt; &lt;li&gt;&lt;a ui-sref="app.page1"&gt;app.page1&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a ui-sref="app.page2"&gt;app.page2&lt;/a&gt;&lt;/li &lt;/ol&gt; &lt;/script&gt; &lt;script type="text/ng-template" id="'nav2.html'"&gt; &lt;ol&gt; &lt;li&gt;&lt;a ui-sref="test.page1(&#123;id:1&#125;)"&gt;test.page1&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a ui-sref="test.page2"&gt;test.page2&lt;/a&gt;&lt;/li &lt;/ol&gt; &lt;/script&gt; &lt;script type="text/ng-template" id="'page1.html'"&gt; this is page 1 for app. &lt;/script&gt; &lt;script type="text/ng-template" id="'page2.html'"&gt; this is page 2 for app. &lt;/script&gt; &lt;script type="text/ng-template" id="'page3.html'"&gt; this is page 1 for test. &lt;/script&gt; &lt;script type="text/ng-template" id="'page4.html'"&gt; this is page 2 for test. &lt;/script&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051angular.module('Demo', ['ui.router']).config(["$stateProvider","$urlRouterProvider",routeConfig]).controller("testCtrl", angular.noop)function routeConfig($stateProvider,$urlRouterProvider)&#123; $urlRouterProvider.otherwise("/app/page1"); $stateProvider .state("app",&#123; url:"/app", views:&#123; "":&#123; templateUrl:"'layout.html'" &#125;, "nav":&#123; templateUrl:"'nav1.html'" &#125; &#125; &#125;) .state("app.page1",&#123; url:"/page1", templateUrl:"'page1.html'" &#125;) .state("app.page2",&#123; url:"/page2", templateUrl:"'page2.html'" &#125;) .state("test",&#123; url:"/test", views:&#123; "":&#123; templateUrl:"'layout.html'" &#125;, "nav":&#123; templateUrl:"'nav2.html'" &#125; &#125; &#125;) .state("test.page1",&#123; url:"/page1?:id", templateUrl:"'page3.html'", controller:["$stateParams",function($stateParams)&#123; console.log($stateParams.id);// 1 这里实现传参 &#125;], params:&#123; id:null &#125; &#125;) .state("test.page2",&#123; url:"/page2", templateUrl:"'page4.html'" &#125;)&#125; 参考文档https://github.com/angular-ui/ui-router/wiki/Quick-Reference]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Gulp构建前端自动化]]></title>
      <url>%2F2017%2F04%2F14%2FGulp%E6%9E%84%E5%BB%BA%E5%89%8D%E7%AB%AF%E8%87%AA%E5%8A%A8%E5%8C%96%2F</url>
      <content type="text"><![CDATA[Gulp简介gulp是前端开发过程中一种基于流的代码构建工具，是自动化项目的构建利器；她能自动化地完成 javascript、coffee、sass、less、html/image、css等文件的测试、检查、合并、压缩、格式化、浏览器自动刷新、部署文件生成，并监听文件在改动后重复指定的这些步骤。在实现上，她借鉴了Unix操作系统的管道（pipe）思想，前一级的输出，直接变成后一级的输入，使得在操作上非常简单。特点： 易于使用：通过代码优于配置的策略，gulp 让简单的任务简单，复杂的任务可管理。 构建快速：利用 Node.js 流的威力，你可以快速构建项目并减少频繁的 IO 操作。 易于学习：通过最少的 API，掌握gulp毫不费力，如同一系列流管道。 插件丰富：gulp 严格的插件指南确保插件如你期望的那样简洁高质得工作。 安装首先确保你已经正确安装了nodejs环境。然后以全局方式安装gulp：1npm install -g gulp 全局安装gulp后，还需要在每个要使用gulp的项目中都单独安装一次。把目录切换到你的项目文件夹中，然后在命令行中执行：1npm install gulp 如果想在安装的时候把gulp写进项目package.json文件的依赖中，则可以加上–save-dev：1npm install --save-dev gulp 这样就完成了gulp的安装，接下来就可以在项目中应用gulp了。 使用第一步：建立gulpfile.js文件 gulp需要一个文件作为它的主文件，这个文件就是gulpfile.js。新建一个文件名为gulpfile.js的文件，然后放到你的项目目录中。之后要做的事情就是在gulpfile.js文件中定义任务。下面是一个最简单的gulpfile.js文件内容示例，它定义了一个默认的任务。1234var gulp = require('gulp');gulp.task('default',function()&#123; console.log('hello world');&#125;); 第二步：运行gulp任务 要运行gulp任务，只需切换到存放gulpfile.js文件的目录，然后在命令行中执行gulp命令就行了，gulp后面可以加上要执行的任务名，例如gulp task1，如果没有指定任务名，则会执行任务名为default的默认任务。 常用方法src()gulp.src()方法正是用来获取流的，但要注意这个流里的内容不是原始的文件流，而是一个虚拟文件对象流，这个虚拟文件对象中存储着原始文件的路径、文件名、内容等信息。其语法为：1gulp.src(globs[, options]); globs参数是文件匹配模式(类似正则表达式)，用来匹配文件路径(包括文件名)，当然这里也可以直接指定某个具体的文件路径。当有多个匹配模式时，该参数可以为一个数组;类型为String或 Array. options为可选参数。 options.buffer类型： Boolean 默认值： true 如果该项被设置为 false，那么将会以 stream 方式返回 file.contents 而不是文件 buffer 的形式。这在处理一些大文件的时候将会很有用。注意：插件可能并不会实现对 stream 的支持。 options.read类型： Boolean 默认值： true 如果该项被设置为 false， 那么 file.contents 会返回空值（null），也就是并不会去读取文件。 options.base类型： String ， 设置输出路径以某个路径的某个组成部分为基础向后拼接。 例如在一个路径为 client/js/somedir 的目录中，有一个文件叫 somefile.js ：1234567gulp.src('client/js/**/*.js') // 匹配 'client/js/somedir/somefile.js' 现在 `base` 的值为 `client/js/` .pipe(minify()) .pipe(gulp.dest('build')); // 写入 'build/somedir/somefile.js' 将`client/js/`替换为build gulp.src('client/js/**/*.js', &#123; base: 'client' &#125;) // base 的值为 'client' .pipe(minify()) .pipe(gulp.dest('build')); // 写入 'build/js/somedir/somefile.js' 将`client`替换为build desk()gulp.dest()方法是用来写文件的，其语法为：1gulp.dest(path[,options]) path为写入文件的路径；options为一个可选的参数对象，以下为选项参数： options.cwd类型： String 默认值： process.cwd() 输出目录的 cwd 参数，只在所给的输出目录是相对路径时候有效。 options.mode类型： String 默认值： 0777 八进制权限字符，用以定义所有在输出目录中所创建的目录的权限。123var gulp = require('gulp');gulp.src('script/jquery.js') // 获取流 .pipe(gulp.dest('dist/foo.js')); // 写放文件 下面再说说生成的文件路径与我们给gulp.dest()方法传入的路径参数之间的关系。 gulp.dest(path)生成的文件路径是我们传入的path参数后面再加上gulp.src()中有通配符开始出现的那部分路径。例如：12345var gulp = reruire('gulp');//有通配符开始出现的那部分路径为 **/*.jsgulp.src('script/**/*.js') .pipe(gulp.dest('dist')); //最后生成的文件路径为 dist/**/*.js//如果 **/*.js 匹配到的文件为 jquery/jquery.js ,则生成的文件路径为 dist/jquery/jquery.js 用gulp.dest()把文件流写入文件后，文件流仍然可以继续使用。 watch()gulp.watch()用来监视文件的变化，当文件发生变化后，我们可以利用它来执行相应的任务，例如文件压缩等。其语法为1gulp.watch(glob[, opts], tasks); glob 为要监视的文件匹配模式，规则和用法与gulp.src()方法中的glob相同。 opts 为一个可选的配置对象，通常不需要用到。tasks为文件变化后要执行的任务，为一个数组。1234567gulp.task('uglify',function()&#123; //do something&#125;);gulp.task('reload',function()&#123; //do something&#125;);gulp.watch('js/**/*.js', ['uglify','reload']); gulp.watch()还有另外一种使用方式：1gulp.watch(glob[, opts, cb]); glob和opts参数与第一种用法相同; cb参数为一个函数。每当监视的文件发生变化时，就会调用这个函数,并且会给它传入一个对象，该对象包含了文件变化的一些信息，type属性为变化的类型，可以是added,changed,deleted；path属性为发生变化的文件的路径。1234gulp.watch('js/**/*.js', function(event)&#123; console.log(event.type); //变化类型added为新增,deleted为删除，changed为改变 console.log(event.path); //变化的文件的路径&#125;); task()gulp.task()方法用来定义任务，内部使用的是Orchestrator(用于排序、执行任务和最大并发依赖关系的模块)，其语法为：1gulp.task(name[, deps], fn) name 为任务名； deps 是当前定义的任务需要依赖的其他任务，为一个数组。当前定义的任务会在所有依赖的任务执行完毕后才开始执行。如果没有依赖，则可省略这个参数； fn 为任务函数，任务执行的代码都写在里面。该参数也是可选的。 当你定义一个简单的任务时，需要传入任务名字和执行函数两个属性。123gulp.task(&apos;greet&apos;, function () &#123; console.log(&apos;Hello world!&apos;);&#125;); 执行gulp greet的结果就是在控制台上打印出“Hello world”。 你也可以定义一个在gulp开始运行时候默认执行的任务，并将这个任务命名为default：123gulp.task(&apos;default&apos;, function () &#123; // Your default task&#125;); 当有多个任务时，可以通过任务依赖来控制任务的执行顺序。 例如执行one,two,three这三个任务，那我们就可以定义一个空的任务，然后把那三个任务当做这个空的任务的依赖就行了：12//只要执行default任务，就相当于把one,two,three这三个任务执行了gulp.task('default',['one','two','three']); 如果任务相互之间没有依赖，任务就会按你书写的顺序来执行，如果有依赖的话则会先执行依赖的任务。但是如果某个任务所依赖的任务是异步的，就要注意了，gulp并不会等待那个所依赖的异步任务完成，而是会接着执行后续的任务。例如：1234567891011gulp.task('one',function()&#123; //one是一个异步执行的任务 setTimeout(function()&#123; console.log('one is done') &#125;,5000);&#125;); //two任务虽然依赖于one任务,但并不会等到one任务中的异步操作完成后再执行gulp.task('two',['one'],function()&#123; console.log('two is done');&#125;); 上面的例子中执行two任务时，会先执行one任务，但不会去等待one任务中的异步操作完成后再执行two任务，而是紧接着执行two任务。所以two任务会在one任务中的异步操作完成之前就执行了。 那如果我们想等待异步任务中的异步操作完成后再执行后续的任务，该怎么做呢？ 有三种方法可以实现： 第一：在异步操作完成后执行一个回调函数来通知gulp这个异步任务已经完成,这个回调函数就是任务函数的第一个参数。123456789101112gulp.task('one',function(cb)&#123; //cb为任务函数提供的回调，用来通知任务已经完成 //one是一个异步执行的任务 exec(function()&#123; console.log('one is finish'); cb(); //执行回调，表示这个异步任务已经完成 &#125;,5000);&#125;); //这时two任务会在one任务中的异步操作完成后再执行gulp.task('two',['one'],function()&#123; console.log('two is finish');&#125;); 第二：定义任务时返回一个流对象。适用于任务就是操作gulp.src获取到的流的情况。12345678910gulp.task('one',function(cb)&#123; var stream = gulp.src('client/**/*.js') .pipe(exec()) //exec()中有某些异步操作 .pipe(gulp.dest('build')); return stream;&#125;); gulp.task('two',['one'],function()&#123; console.log('two is done');&#125;); 第三：返回一个promise对象，例如1234567891011121314var Q = require('q');gulp.task('one', function() &#123; var deferred = Q.defer(); // 执行异步的操作 setTimeout(function() &#123; deferred.resolve(); &#125;, 1); return deferred.promise;&#125;); gulp.task('two',['one'],function()&#123; console.log('two is done');&#125;); run()gulp.run()表示要执行的任务。可能会使用单个参数的形式传递多个任务。如下代码：123gulp.task('end',function()&#123; gulp.run('task1','task3','task2');&#125;); 注意：任务是尽可能多的并行执行的，并且可能不会按照指定的顺序运行。 常用插件自动加载gulp-load-plugins这个插件能自动帮你加载package.json文件里的gulp插件。例如假设package.json文件里的依赖是这样的:12345678&#123; "devDependencies": &#123; "gulp": "~3.6.0", "gulp-rename": "~1.2.0", "gulp-ruby-sass": "~0.4.3", "gulp-load-plugins": "~0.5.1" &#125;&#125; 然后我们可以在gulpfile.js中使用gulp-load-plugins来帮我们加载插件：123var gulp = require(&apos;gulp&apos;);//加载gulp-load-plugins插件，并马上运行它var plugins = require(&apos;gulp-load-plugins&apos;)(); 然后我们要使用gulp-rename和gulp-ruby-sass这两个插件的时候，就可以使用plugins.rename和plugins.rubySass来代替了,也就是原始插件名去掉gulp-前缀，之后再转换为驼峰命名。 重命名gulp-rename插件用来重命名文件流中的文件。用gulp.dest()方法写入文件时，文件名使用的是文件流中的文件名，如果要想改变文件名，那可以在之前用gulp-rename插件来改变文件流中的文件名。12345678910var gulp = require('gulp'), rename = require('gulp-rename'), uglify = require("gulp-uglify"); gulp.task('rename', function () &#123; gulp.src('src/1.js') .pipe(uglify()) //压缩 .pipe(rename('1.min.js')) //会将1.js重命名为1.min.js .pipe(gulp.dest('js')); // 压缩后的路径&#125;); js文件压缩gulp-uglify插件用来压缩js文件。1234567var gulp = require('gulp'), uglify = require("gulp-uglify"); gulp.task('minify-js', function () &#123; gulp.src('src/*.js') // 要压缩的js文件 .pipe(uglify()) // 使用uglify进行压缩 .pipe(gulp.dest('dist/js')); css文件压缩gulp-minify-css插件用来压缩css文件。12345678var gulp = require('gulp'), minifyCss = require("gulp-minify-css"); gulp.task('minify-css', function () &#123; gulp.src('src/*.css') // 要压缩的css文件 .pipe(minifyCss()) // 压缩css .pipe(gulp.dest('dist/css'));&#125;); html文件压缩gulp-minify-html插件用来压缩html文件。12345678var gulp = require('gulp'), minifyHtml = require("gulp-minify-html"); gulp.task('minify-html', function () &#123; gulp.src('src/*.html') // 要压缩的html文件 .pipe(minifyHtml()) // 压缩 .pipe(gulp.dest('dist/html'));&#125;); js代码检查使用gulp-jshint插件，用来检查js代码。12345678var gulp = require('gulp'), jshint = require("gulp-jshint"); gulp.task('jsLint', function () &#123; gulp.src('src/*.js') .pipe(jshint()) .pipe(jshint.reporter()); // 输出检查结果&#125;); 文件合并gulp-concat插件，用来把多个文件合并为一个文件,我们可以用它来合并js或css文件等。1234567var gulp = require('gulp'), concat = require("gulp-concat");gulp.task('concat', function () &#123; gulp.src('src/*.js') // 要合并的文件 .pipe(concat('all.js')) // 合并匹配到的js文件并命名为 "all.js" .pipe(gulp.dest('dist/js'));&#125;); 图片压缩gulp-imagemin插件来压缩jpg、png、gif等图片。1234567891011var gulp = require('gulp');var imagemin = require('gulp-imagemin');var pngquant = require('imagemin-pngquant'); //png图片压缩插件gulp.task('default', function () &#123; return gulp.src('src/images/*') .pipe(imagemin(&#123; progressive: true, use: [pngquant()] //使用pngquant来压缩png图片 &#125;)) .pipe(gulp.dest('dist'));&#125;); 自动刷新使用gulp-livereload插件，当代码变化时，它可以帮我们自动刷新页面。12345678910111213var gulp = require('gulp'), less = require('gulp-less'), livereload = require('gulp-livereload');gulp.task('less', function() &#123; gulp.src('less/*.less') .pipe(less()) .pipe(gulp.dest('css')) .pipe(livereload());&#125;);gulp.task('watch', function() &#123; livereload.listen(); //要在这里调用listen()方法 gulp.watch('less/*.less', ['less']);&#125;); 启动服务器使用gulp-connect插件，可以启动一个本地服务器,常与gulp-livereload插件一块使用123456789var gulp = require("gulp"), connect = require('gulp-connect'); gulp.task('server', function() &#123; connect.server(&#123; livereload: true, port: 5000 //端口号 &#125;);&#125;);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript Namespace命名空间使用说明]]></title>
      <url>%2F2017%2F04%2F14%2FJavaScript-Namespace%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E%2F</url>
      <content type="text"><![CDATA[什么是命名空间？语言使用的一种代码组织的形式 通过名称空间来分类，区别不同的代码功能 。无论项目大小，如果一开始不严格按照命名空间来编写程序，当你写到上万行JavaScript程序的时候，我相信你一定会后悔你的object或者function命名已经很混乱了。所以建议童鞋们一开始就要养成命名空间的习惯，比如你要开发一个项目，功能可能如下：12345678910111213141516171819202122232425262728293031// 配置 var config = &#123;&#125;; // 前台 config.front = &#123;&#125;; // 后台 config.admin = &#123;&#125;; // 后台数据 config.admin.data = &#123;&#125;; // 后台模块 config.admin.module = &#123;&#125;; // 后台颜色模块 config.admin.module.color = &#123;&#125;; // 后台图片模块 config.admin.module.images = &#123;&#125;; // 后台搜索模块 config.admin.module.search = &#123;&#125;; // 给后台颜色模块加背景颜色改变功能 config.admin.module.color.changeBgColor = function(color) &#123; document.body.style.background = color; &#125;; // 可以这么调用 config.admin.module.color.changeBgColor('#F30'); 但是，以上声明命名空间的方式看起来不直观，我们来一个比较直观的结构化命名方式：1234567891011121314151617181920212223242526272829303132333435363738// 配置 var config = &#123; // 前台 front : &#123;&#125;, // 后台 admin : &#123; // 数据层 data : &#123;&#125;, // 模块层 module : &#123; // 颜色模块 color : &#123; // 背景颜色改变功能 changeBgColor : function(color)&#123; document.body.style.background = color; &#125;, // 前景颜色改变功能 changeFnColor : function(color)&#123; document.body.style.color = color; &#125; &#125;, // 图片模块 images : &#123; &#125;, // 搜索模块 search : &#123; &#125; &#125; &#125; &#125;; // 可以这么调用 config.admin.module.color.changeBgColor('#F30'); 以上的声明方式就把结构化很好的呈现出来了，利用命名空间非常方便的管理维护拓展程序，当多人开发或者JavaScript代码写的数量巨大时不用担心命名冲突的问题。我们也可以写一个命名空间的功能，省去以上复杂的声明方式。 比如以上例子实际上我只是暂时用到config.admin.module.color.changeBgColor这个功能，那么我就需要先定义config，接着admin，然后module，最后是color.changeBgColor，比较繁琐，于是我们可以写一个命名空间注册的功能，直接注册就能用：123456789101112131415161718192021222324252627282930// 命名空间注册函数 var namespace = &#123; reg : function(s)&#123; var arr = s.split('.'); var namespace = window; for(var i=0,k=arr.length;i&lt;k;i++)&#123; if(typeof namespace[arr[i]] == 'undefined')&#123; namespace[arr[i]] = &#123;&#125;; &#125; namespace = namespace[arr[i]]; &#125; &#125;, del : function(s)&#123; var arr = s.split('.'); var namespace = window; for(var i=0,k=arr.length;i&lt;k;i++)&#123; if(typeof namespace[arr[i]] == 'undefined')&#123; return; &#125;else if( k == i+1 )&#123; delete namespace[arr[i]]; return; &#125;else&#123; namespace = namespace[arr[i]]; &#125; &#125; &#125; &#125;; 可以这样注册命名空间12345678910111213// 先注册命名空间 namespace.reg(&apos;config.admin.module.color&apos;); // 添加功能 config.admin.module.color.changeBgColor = function(color)&#123; document.body.style.background = color; &#125;; // 调用功能 config.admin.module.color.changeBgColor(&apos;#F30&apos;); // 删除命名空间 namespace.del(&apos;config.admin.module.color&apos;); 命名空间没有唯一规则，只有根据每个项目以及项目负责人对程序的分析然后给出一定命名规则，比如有些项目根据功能命名空间，有些项目根据负责人名命名空间等等。但无论采用哪种方式，合理的命名空间在你应对大项目时多人合作时不会因为命名冲突而重构。因此你的站点中的js文件将有一篇是第一位引入的namespace.js，它定义了这个项目所有的命名空间与管理。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[使用artTemplate模板引擎开发网站]]></title>
      <url>%2F2016%2F12%2F28%2F%E4%BD%BF%E7%94%A8artTemplate%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E%E5%BC%80%E5%8F%91%E7%BD%91%E7%AB%99%2F</url>
      <content type="text"><![CDATA[artTemplateartTemplate是一款性能卓越的 javascript 模板引擎。它采用预编译方式让性能有了质的飞跃，并且充分利用 javascript 引擎特性，使得其性能无论在前端还是后端都有极其出色的表现。在 chrome 下渲染效率测试中分别是知名引擎 Mustache 与 micro tmpl 的 25 、 32 倍（性能测试）。除了性能优势外，调试功能也值得一提。模板调试器可以精确定位到引发渲染错误的模板语句，解决了编写模板过程中无法调试的痛苦，让开发变得高效，也避免了因为单个模板出错导致整个应用崩溃的情况发生。 下载： 简洁语法版(推荐) 、 原生语法版 、 Github 特性 性能卓越，执行速度通常是 Mustache 与 tmpl 的 20 多倍（性能测试） 支持运行时调试，可精确定位异常模板所在语句（演示） 对 NodeJS Express 友好支持 安全，默认对输出进行转义、在沙箱中运行编译后的代码（Node版本可以安全执行用户上传的模板） 支持include语句，可在浏览器端实现按路径加载模板 支持预编译，可将模板转换成为非常精简的 js 文件 模板语句简洁，无需前缀引用数据 支持所有流行的浏览器 作为前端模版引擎快速上手编写模版创建一个html文件，引入template.js，然后在正文中放置一个id为content的div标签，用来存放接下来根据模板动态生成的html内容。12345678910&lt;html&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;demo&lt;/title&gt; &lt;script src="template.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=”content”&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 使用一个type=&quot;text/html&quot;的script标签存放模板：12345678&lt;script id="test" type="text/html"&gt; &lt;h1&gt;&#123;&#123;title&#125;&#125;&lt;/h1&gt; &lt;ul&gt; &#123;&#123;each list as value i&#125;&#125; &lt;li&gt;索引 &#123;&#123;i + 1&#125;&#125; ：&#123;&#123;value&#125;&#125;&lt;/li&gt; &#123;&#123;/each&#125;&#125; &lt;/ul&gt;&lt;/script&gt; 渲染模版12345678&lt;script&gt;var data = &#123; title: '标签', list: ['文艺', '博客', '摄影', '电影', '民谣', '旅行', '吉他']&#125;;var html = template.render('test', data);document.getElementById('content').innerHTML = html;&lt;/script&gt; 演示 不转义HTML模板引擎默认数据包含的 HTML 字符进行转义以避免 XSS 漏洞，若不需要转义的地方可使用==。123&lt;script id="test" type="text/html"&gt; &#123;&#123;#value&#125;&#125;&lt;/script&gt; 若需要关闭默认转义，可以设置template.isEscape = false。演示 在js中存放模板template.compile([id], source)将返回一个渲染函数。其中 id 参数是可选的，如果使用了 id 参数，可以使用template.render(id, data)渲染模板。1234567891011121314&lt;script&gt;var source = '&lt;ul&gt;'+ '&#123;&#123;each list as value i&#125;&#125;'+ '&lt;li&gt;索引 &#123;&#123;i + 1&#125;&#125; ：&#123;&#123;value&#125;&#125;&lt;/li&gt;'+ '&#123;&#123;/each&#125;&#125;'+ '&lt;/ul&gt;';var render = template.compile(source);var html = render(&#123; list: ['摄影', '电影', '民谣', '旅行', '吉他']&#125;);document.getElementById('content').innerHTML = html;&lt;/script&gt; 演示 添加辅助方法template.helper(name, callback)辅助方法一般用来进行输出字符串或字符串替换。例如编写一个显示当前时间的辅助方法：12345678910template.helper('dateFormat', function (date, format) &#123; //.. return value;&#125;);var data = &#123; time: (new Date).toString(),&#125;;var html = template('test', data);document.getElementById('content').innerHTML = html; 在模板中的使用方式：1&#123;&#123;time | dateFormat:'yyyy年 MM月 dd日 hh:mm:ss'&#125;&#125; 支持传入参数与嵌套使用：1&#123;&#123;time | say:'cd' | ubb | link&#125;&#125; 注意：引擎不会对辅助方法输出的 HTML 字符进行转义。演示 作为后端引擎使用(配合node.js)安装art-template1npm install art-template --save 编写artTemplate模板在工作区下，创建index.html，并将如下代码输入index.html，保存。其中&lt;ul&gt;标签中的内容，就是模板代码。1234567&lt;div id='main'&gt; &lt;ul&gt; &#123;&#123;each list&#125;&#125; &lt;li&gt;编号：&#123;&#123;$value.id&#125;&#125; &amp;nbsp;&amp;nbsp;姓名：&#123;&#123;$value.name&#125;&#125;&lt;/a&gt;&lt;/li&gt; &#123;&#123;/each&#125;&#125; &lt;/ul&gt;&lt;/div&gt; 渲染模板还记得template(id, data)方法吗？这是在前端DOM环境下的用法。 其实在NodeJS环境下，它就相当于template(filename, data)了，可以将需要渲染的模板文件名当作路径传给它的第一个参数。12345678910111213var http = require('http');var os = require('os');http.createServer(function(request, response) &#123; var template = require('art-template'); //数据 var data = &#123;list: [&#123;id:'1', name:'张三'&#125;, &#123;id:'2', name:'李四'&#125;]&#125;; //渲染模板 var html = template('./index', data); response.writeHead(200, &#123;'Content-Type': 'text/html'&#125;); response.write(html); response.end();&#125;).listen(3000);console.log("Server is running, listening on port 3000…"); 配置base指定模板目录可以缩短模板的路径，并且能够避免include语句越级访问任意路径引发安全隐患。例如：12template.config('base', __dirname);var html = template('index/main', data) 在Windows命令行下，进入工作区，执行node server.js，服务器就启动了。 此时在本地机器上使用浏览器访问http://localhost:3000将会看到Html输出了。 搭配express使用express框架是由javascript语言开发的，基于Node.js平台的，快速、开放、极简的web开发框架。 安装art-template1npm install art-template --save 改造app.jsapp.js是express的主要文件，这个文件里包含了指定模板引擎、指定视图文件默认路径的代码。需要将指定模板引擎的代码改为指定用art-template引擎。视图文件默认路径保持不变，因此无需改动。123456789//首先，引入artTemplate模块var template = require('art-template');//用art-template引擎替换默认的jade引擎template.config('base', '');template.config('extname', '.html');app.engine('.html', template.__express);app.set('view engine', 'html');//app.set('view engine', 'jade'); 编写artTemplate模板进入express文件夹中的views子文件夹，创建index.html，并将如下代码输入index.html，并保存。1234567&lt;div id='main'&gt; &lt;ul&gt; &#123;&#123;each list as value i&#125;&#125; &lt;li&gt;索引 &#123;&#123;i + 1&#125;&#125; ：&#123;&#123;value&#125;&#125;&lt;/li&gt; &#123;&#123;/each&#125;&#125; &lt;/ul&gt;&lt;/div&gt; 渲染模版express默认访问index路由。进入routes文件夹，打开router.js，增加渲染模板的代码，如下：123456789router.get('/', function(req, res, next) &#123; // 数据 var data = &#123; title: '标签', list: ['文艺', '博客', '摄影', '电影', '民谣', '旅行', '吉他'] &#125;; // 渲染模板 res.render('index', data);&#125;); 代码中的res.render(&#39;index&#39;, data)调用，会调用artTemple模块中的template.__express方法，并传入模板文件名、数据。 template.__express方法是在app.js中注册给express框架的。 预编译工具使用预编译工具可以让前端模版不再受浏览器的限制，支持如后端模版一样按文件放置、include 语句等特性，可以像后端一样书写前端模板！ 编译后的模板不再依赖前端模板引擎与后端，模板可以通过 SeaJS 或 RequireJS 等加载器进行异步加载，亦能利用它们成熟的打包合并工具进行上线前的优化，如合并与压缩。 预编译工具：TmodJS TmodJS 一经启动，就无需人工干预，每次模板创建与更新都会自动编译，引入一个 js 即可使用template(path)接口调用本地模板文件，直到正式上线都无需对代码进行任何修改，整个过程简单自然。 安装TmodJS1npm install -g tmodjs 编译模板只需要运行tmod这个命令即可，默认配置参数可以满足绝大多数项目。1tmod [模板目录] [配置参数] 模板目录必须是模板的根目录，若无参数则为默认使用当前工作目录，tmodjs 会监控模板目录修改，每次模板修改都会增量编译。 配置参数 --debug 输出调试版本 --charset value 定义模板编码，默认utf-8 --output value 定义输出目录，默认./build --type value 定义输出模块格式，默认default，可选cmd、amd、commonjs --no-watch 关闭模板目录监控 --version 显示版本号 --help 显示帮助信息 配置参数将会保存在模板目录配置文件中，下次运行无需输入配置参数（–no-watch 与 –debug 除外）。 示例1tmod ./tpl --output ./build 使用模板根据编译的type的配置不同，会有两种不同使用方式： 使用默认的格式TmodJS 默认将整个目录的模板压缩打包到一个名为 template.js 的脚本中，可直接在页面中使用它：12345&lt;script src="tpl/build/template.js"&gt;&lt;/script&gt;&lt;script&gt; var html = template('news/list', _list); document.getElementById('list').innerHTML = html;&lt;/script&gt; template.js 还支持 RequireJS、SeaJS、NodeJS 加载。示例 指定格式（amd / cmd / commonjs)此时每个模板就是一个单独的模块，无需引用 template.js： 12var render = require('./tpl/build/news/list');var html = render(_list); 注意：模板路径不能包含模板后缀名 演示TmodJS 源码包中test/tpl是一个演示项目的前端模板目录，基于默认配置。切换到源码目录后，编译： 1tmod test/tpl 编译完毕后你可以在浏览器中打开 test/index.html 查看如何使用编译后的模板。 配置TmodJS 的项目配置文件保存在模板目录的 package.json 文件中： 1234567891011121314151617181920&#123; "name": "template", "version": "1.0.0", "dependencies": &#123; "tmodjs": "1.0.0" &#125;, "tmodjs-config": &#123; "output": "./build", "charset": "utf-8", "syntax": "simple", "helpers": null, "escape": true, "compress": true, "type": "default", "runtime": "template.js", "combo": true, "minify": true, "cache": false &#125;&#125; 字段 类型 默认值 说明 output String &quot;./build&quot; 编译输出目录设置。如果设置为 false 则不输出 charset String &quot;utf-8&quot; 模板使用的编码（暂时只支持 utf-8） syntax String &quot;simple&quot; 定义模板采用哪种语法。可选：simple、native helpers String null 自定义辅助方法路径 escape Boolean true 是否过滤 XSS。如果后台给出的数据已经进行了 XSS 过滤，就可以关闭模板的过滤以提升模板渲染效率 compress Boolean true 是否压缩 HTML 多余空白字符 type String &quot;default&quot; 输出的模块类型，可选：default、cmd、amd、commonjs runtime String &quot;template.js&quot; 设置输出的运行时名称 alias String null 设置模块依赖的运行时路径（仅针对于非default的类型模块配置字段。如果不指定模块内部会自动使用相对 runtime 的路径） combo Boolean true 是否合并模板（仅针对于 default 类型的模块） minify Boolean true 是否输出为压缩的格式 cache Boolean true 是否开启编译缓存 verbose Boolean true 是否打印日志]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Loader.css - CSS3实现加载动画]]></title>
      <url>%2F2016%2F12%2F23%2FLoader-css-CSS3%E5%AE%9E%E7%8E%B0%E5%8A%A0%E8%BD%BD%E5%8A%A8%E7%94%BB%2F</url>
      <content type="text"><![CDATA[当网页的页面大小较大，用户加载可能需要较长的时间，在这些情况下，我们一般会用到（加载）loading动画，提示于用户页面在加载中，这些UX常识我想很多设计师都懂，但做一个GIF动画有点麻烦，为了方便，为大家分享Loader.css，仅用CSS3就能实现一个loading动画效果。Loader.css当前支持28个动画效果。 使用方法Step 1: 引入 loaders.min.css 和 loaders.css.js，这个JS仅是为了简化动画的DIV标签，如果不加这个JS，那么你的动画就必须加上对应数量DIV标签才能正常显示动画，所以建议加上，这样语义化好会好些。12&lt;link rel="stylesheet" type="text/css" href="loaders.min.css"&gt;&lt;script type="text/javascript" src="loaders.css.js"&gt;&lt;/script&gt; Step 2: HTML代码，给loading元素加入动画class，如下：1&lt;div class="loader-inner ball-pulse"&gt;&lt;/div&gt; 改变加载动画颜色此外你还要可以为loading动画加上颜色，代码如下：123.ball-grid-pulse &gt; div &#123; background: orange;&#125; 浏览器兼容性 IE 11 Firefox 36 Chrome 41 Safari 8 ✔ ✔ ✔ ✔ 虽然不兼容IE8或以下版本，但我觉得已经够用了，目前现在用IE10和手机浏览网页的用户也很多了。 在线预览DEMO下载地址]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Js模块化开发]]></title>
      <url>%2F2016%2F12%2F23%2FJs%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91%2F</url>
      <content type="text"><![CDATA[前言前端开发中，起初只要在script标签中嵌入几十上百行代码就能实现一些基本的交互效果，后来js得到重视，应用也广泛起来了，jQuery，Ajax，Node.Js，MVC，MVVM等的助力也使得前端开发得到重视，也使得前端项目越来越复杂，然而，JavaScript却没有为组织代码提供任何明显帮助，甚至没有类的概念，更不用说模块（module）了，那么什么是模块呢？ 一个模块就是实现特定功能的文件，有了模块，我们就可以更方便地使用别人的代码，想要什么功能，就加载什么模块。模块开发需要遵循一定的规范，否则就都乱套了。根据AMD规范，我们可以使用define定义模块，使用require调用模块。目前，通行的js模块规范主要有两种：CommonJS和AMD。 AMD规范AMD 即Asynchronous Module Definition，中文名是“异步模块定义”的意思。它是一个在浏览器端模块化开发的规范，服务器端的规范是CommonJS模块将被异步加载，模块加载不影响后面语句的运行。所有依赖某些模块的语句均放置在回调函数中。AMD 是 RequireJS 在推广过程中对模块定义的规范化的产出。 define() 函数AMD规范只定义了一个函数 define，它是全局变量。函数的描述为：1define(id?, dependencies?, factory); 参数说明： id：指定义中模块的名字，可选；如果没有提供该参数，模块的名字应该默认为模块加载器请求的指定脚本的名字。如果提供了该参数，模块名必须是“顶级”的和绝对的（不允许相对名字）。 依赖dependencies：是一个当前模块依赖的，已被模块定义的模块标识的数组字面量。依赖参数是可选的，如果忽略此参数，应该默认为[“require”, “exports”, “module”]。然而，如果工厂方法的长度属性小于3，加载器会选择以函数的长度属性指定的参数个数调用工厂方法。 工厂方法factory：模块初始化要执行的函数或对象。如果为函数，它应该只被执行一次。如果是对象，此对象应该为模块的输出值。 模块名的格式模块名用来唯一标识定义中模块，它们同样在依赖性数组中使用： 模块名是用正斜杠分割的有意义单词的字符串 单词须为驼峰形式，或者”.”，”..” 模块名不允许文件扩展名的形式，如“.js” 模块名可以为 “相对的” 或 “顶级的”。如果首字符为“.”或“..”则为相对的模块名 顶级的模块名从根命名空间的概念模块解析 相对的模块名从 “require” 书写和调用的模块解析 使用 require 和 exports创建一个名为”alpha”的模块，使用了require，exports，和名为”beta”的模块:123456define("alpha", ["require", "exports", "beta"], function (require, exports, beta) &#123; exports.verb = function() &#123; return beta.verb(); //Or:return require("beta").verb(); &#125; &#125;); require API 介绍 目前，实现AMD的库有RequireJS、curl 、Dojo 、Nodules 等。 CommonJS规范CommonJS是服务器端模块的规范，Node.js采用了这个规范。Node.JS首先采用了js模块化的概念。根据CommonJS规范，一个单独的文件就是一个模块。每一个模块都是一个单独的作用域，也就是说，在该模块内部定义的变量，无法被其他模块读取，除非定义为global对象的属性。输出模块变量的最好方法是使用module.exports对象。 123456789var i = 1;var max = 30;module.exports = function () &#123; for (i -= 1; i++ &lt; max; ) &#123; console.log(i); &#125; max *= 1.1;&#125;; 上面代码通过module.exports对象，定义了一个函数，该函数就是模块外部与内部通信的桥梁。 加载模块使用require方法，该方法读取一个文件并执行，最后返回文件内部的module.exports对象。 AMD和CMDCMD（Common Module Definition）通用模块定义。该规范明确了模块的基本书写格式和基本交互规则。该规范是在国内发展出来的。AMD是依赖关系前置，CMD是按需加载。在 CMD 规范中，一个模块就是一个文件。代码的书写格式如下：1define(factory); factory 为函数时，表示是模块的构造方法。执行该构造方法，可以得到模块向外提供的接口。factory 方法在执行时，默认会传入三个参数：require、exports 和 module：12345define(function(require, exports, module) &#123; // 模块代码&#125;); require是可以把其他模块导入进来的一个参数，而export是可以把模块内的一些属性和方法导出的。 CMD规范 AMD 是 RequireJS 在推广过程中对模块定义的规范化产出。CMD 是 SeaJS 在推广过程中对模块定义的规范化产出。对于依赖的模块，AMD 是提前执行，CMD 是延迟执行。AMD:提前执行（异步加载：依赖先执行）+延迟执行CMD:延迟执行（运行到需加载，根据顺序执行）CMD 推崇依赖就近，AMD 推崇依赖前置。看如下代码：123456789// CMDdefine(function(require, exports, module) &#123; var a = require('./a') a.doSomething() // 此处略去 100 行 var b = require('./b') // 依赖可以就近书写 b.doSomething() // ... &#125;) 1234567// AMD 默认推荐的是define(['./a', './b'], function(a, b) &#123; // 依赖必须一开始就写好 a.doSomething() // 此处略去 100 行 b.doSomething() ...&#125;) 另外一个区别是：AMD:API根据使用范围有区别，但使用同一个api接口CMD:每个API的职责单一AMD的优点是：异步并行加载，在AMD的规范下，同时异步加载是不会产生错误的。CMD的机制则不同，这种加载方式会产生错误，如果能规范化模块内容形式，也可以jquery1.7以上版本会自动模块化，支持AMD模式：主要是使用define函数，sea.js虽然是CommonJS规范，但却使用了define来定义模块所以jQuery已经自动模块化了123456seajs.config(&#123; 'base':'/', 'alias':&#123; 'jquery':'jquery.js'//定义jQuery文件 &#125;&#125;); define函数和AMD的define类似：1234567define(function(require, exports, module)&#123; //先要载入jQuery的模块 var $ = require('jquery'); //然后将jQuery对象传给插件模块 require('./cookie')($); //开始使用 $.cookie方法&#125;); RequireJS和SeaJSRequireJS由James Burke创建，他也是AMD规范的创始人。define方法用于定义模块，RequireJS要求每个模块放在一个单独的文件里。RequireJS 和 Sea.js 都是模块加载器，倡导模块化开发理念，核心价值是让 JavaScript 的模块化开发变得简单自然。 SeaJS与RequireJS最大的区别:SeaJS对模块的态度是懒执行, 而RequireJS对模块的态度是预执行 不明白？看这篇图文并茂的文章吧 Requirejs为什么要用requireJS试想一下，如果一个网页有很多的js文件，那么浏览器在下载该页面的时候会先加载js文件，从而停止了网页的渲染，如果文件越多，浏览器可能失去响应。其次，要保证js文件的依赖性，依赖性最大的模块（文件）要放在最后加载，当依赖关系很复杂的时候，代码的编写和维护都会变得困难。RequireJS就是为了解决这两个问题而诞生的：（1）实现js文件的异步加载，避免网页失去响应；（2）管理模块之间的依赖性，便于代码的编写和维护。RequireJS文件下载 使用require.config是用来定义别名的，在paths属性下配置别名。然后通过requirejs(参数一，参数二)；参数一是数组，传入我们需要引用的模块名，第二个参数是个回调函数，回调函数传入一个变量，代替刚才所引入的模块。 12345678910//别名配置requirejs.config(&#123; paths: &#123; jquery: 'jquery.min'//可以省略.js &#125;&#125;);//引入模块，用变量$表示jquery模块requirejs(['jquery'], function ($) &#123; $('body').css('background-color','red');&#125;); 引入模块也可以只写require()。requirejs通过define()定义模块，定义的参数上同。在此模块内的方法和变量外部是无法访问的，只有通过return返回才行.define 模块123456define(['jquery'], function ($) &#123;//引入jQuery模块return &#123; add: function(x,y)&#123; return x + y; &#125; &#125;;&#125;); 将该模块命名为math.js保存。main.js引入模块方法123require(['jquery','math'], function ($,math) &#123; console.log(math.add(10,100));//110&#125;); 如果定义的模块不依赖其他模块，则可以：123456define(function () &#123; return &#123; name: "trigkit4", age: "21" &#125;&#125;); AMD推荐的风格通过返回一个对象做为模块对象，CommonJS的风格通过对module.exports或exports的属性赋值来达到暴露模块对象的目的。 Sea.js如何使用？引入sea.js的库 如何变成模块？ define 如何调用模块？ exports sea.js.use 如何依赖模块？ require 1234567&lt;script type="text/javascript"&gt; define(function (require,exports,module) &#123; //exports : 对外的接口 //requires : 依赖的接口 require('./test.js'); //如果地址是一个模块的话，那么require的返回值就是模块中的exports &#125;)&lt;/script&gt; sea.js 开发实例123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type"content="text/html; charset=utf-8" /&gt;&lt;title&gt;鼠标拖拽的模块化开发实践&lt;/title&gt;&lt;styletype="text/css"&gt;#div1&#123; width:200px; height:200px; background:black; position:absolute; display:none;&#125;#div2&#123; width:30px; height:30px; background:yellow; position:absolute; bottom:0; right:0;&#125;#div3&#123; width:100px; height:100px; background:blue; position:absolute; right:0; top:0;&#125;&lt;/style&gt;&lt;script type="text/javascript" src="./sea.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt;//A同事 ：seajs.use('./main.js');&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;input type="button" value="确定" id="input1" /&gt; &lt;div id="div1"&gt; &lt;div id="div2"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div id="div3"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; A同事1234567891011121314151617//A同事写的main.js:define(function (require,exports,module) &#123; var oInput = document.getElementById('input1'); var oDiv1 = document.getElementById('div1'); var oDiv2 = document.getElementById('div2'); var oDiv3 = document.getElementById('div3'); require('./drag.js').drag(oDiv3); oInput.onclick = function () &#123; oDiv1.style.display = 'block'; require('./scale.js').scale(oDiv1,oDiv2); require.async('./scale.js', function (ex) &#123; ex.scale(oDiv1,oDiv2); &#125;) &#125;&#125;); B同事123456789101112131415161718192021222324252627//B同事写的drag.js:define(function(require,exports,module)&#123; function drag(obj)&#123; var disX = 0; var disY = 0; obj.onmousedown = function(ev)&#123; var ev = ev || window.event; disX = ev.clientX - obj.offsetLeft; disY = ev.clientY - obj.offsetTop; document.onmousemove = function(ev)&#123; var ev = ev || window.event; var L = require('./range.js').range(ev.clientX - disX , document.documentElement.clientWidth - obj.offsetWidth , 0 ); var T = require('./range.js').range(ev.clientY - disY , document.documentElement.clientHeight - obj.offsetHeight , 0 ); obj.style.left = L + 'px'; obj.style.top = T + 'px'; &#125;; document.onmouseup = function()&#123; document.onmousemove = null; document.onmouseup = null; &#125;; return false; &#125;; &#125; exports.drag = drag;//对外提供接口&#125;); C同事1234567891011121314151617181920212223242526272829303132//C同事写的scale.js:define(function(require,exports,module)&#123; function scale(obj1,obj2)&#123; var disX = 0; var disY = 0; var disW = 0; var disH = 0; obj2.onmousedown = function(ev)&#123; var ev = ev || window.event; disX = ev.clientX; disY = ev.clientY; disW = obj1.offsetWidth; disH = obj1.offsetHeight; document.onmousemove = function(ev)&#123; var ev = ev || window.event; var W = require('./range.js').range(ev.clientX - disX + disW , 500 , 100); var H = require('./range.js').range(ev.clientY - disY + disH , 500 , 100); obj1.style.width = W + 'px'; obj1.style.height = H + 'px'; &#125;; document.onmouseup = function()&#123; document.onmousemove = null; document.onmouseup = null; &#125;; return false; &#125;; &#125; exports.scale = scale;&#125;); D同事123456789101112131415// D同事的range.js--限定拖拽范围define(function(require,exports,module)&#123; function range(iNum,iMax,iMin)&#123; if( iNum &gt; iMax )&#123; return iMax; &#125; elseif( iNum &lt; iMin )&#123; return iMin; &#125; else&#123; return iNum; &#125; &#125; exports.range = range;&#125;);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Promise实现原理]]></title>
      <url>%2F2016%2F12%2F22%2FPromise%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%2F</url>
      <content type="text"><![CDATA[Promise 对于一个Jser并不陌生， Promise 类似于一个事务管理器，它的作用就是将各种内嵌回调的事务用流水形式表达。利用 Promise 可以让异步编程更符合人的直觉，让代码逻辑更加清晰，把开发人员从回调地狱中释放出来。这么“高大上”的东西，以前写 nodejs 代码的时候只是简单的用用，还没有理解其基本的实现原理，罪过！个人认为，理解编程思想最好的途径就是阅读一份简易的实现源码。很幸运，网上有不少Promise的简易实现，下面就来好好研究下吧！ 基础概念目前， Promise 是ECMAScript 6 规范的重要特性之一，各大浏览器也开始慢慢支持这一特性。当然，也有一些第三方内库实现了该功能，最流行的如：bluebird等。Promise 对象用来进行延迟( deferred )和异步( asynchronous )计算。一个Promise 处于以下四种状态之一: pending: 还没有得到肯定或者失败结果，进行中 fulfilled: 成功的操作 rejected: 失败的操作 settled: 已被 fulfilled 或 rejected Promise 对象有两个重要的方法，一个是 then ，另一个是 resolve ： then：将事务添加到事务队列中 resolve：开启流程，让整个操作从第一个事务开始执行 Promise 常用方式如下：1234567891011var p = new Promise(function(resolve, reject) &#123; ... // 事务触发 resovle(xxx); ...&#125;);p.then(function(value) &#123; // 满足 &#125;, function(reason) &#123; // 拒绝&#125;).then().then()... 示意图如下： 实现步骤 Promise 其实就是一个状态机。按照它的定义，可从如下基础代码开始： 123456789101112131415161718192021var PENDING = 0; // 进行中 var FULFILLED = 1; // 成功 var REJECTED = 2; // 失败function Promise() &#123; // 存储PENDING, FULFILLED或者REJECTED的状态 var state = PENDING; // 存储成功或失败的结果值 var value = null; // 存储成功或失败的处理程序，通过调用`.then`或者`.done`方法 var handlers = []; // 成功状态变化 function fulfill(result) &#123; state = FULFILLED; value = result; &#125; // 失败状态变化 function reject(error) &#123; state = REJECTED; value = error; &#125;&#125; 下面是 Promise 的 resolve 方法实现：注意：resolve 方法可接收的参数有两种：一个普通的值/对象或者一个 Promise对象。如果是普通的值/对象，则直接把结果传递到下一个对象；如果是一个Promise 对象，则必须先等待这个子任务序列完成。 1234567891011121314151617function Promise() &#123; ... function resolve(result) &#123; try &#123; var then = getThen(result); // 如果是一个promise对象 if (then) &#123; doResolve(then.bind(result), resolve, reject); return; &#125; // 修改状态，传递结果到下一个事务 fulfill(result); &#125; catch (e) &#123; reject(e); &#125; &#125;&#125; 两个辅助方法： 12345678910111213141516171819202122232425262728293031323334353637383940/** * 检查值是否是一个Promise，如果是，返回这个Promise的 `then`方法。 * @param &#123;Promise|Any&#125; value * @return &#123;Function|Null&#125; */function getThen(value) &#123; var t = typeof value; if (value &amp;&amp; (t === 'object' || t === 'function')) &#123; var then = value.then; if (typeof then === 'function') &#123; return then; &#125; &#125; return null;&#125;/** * 确保onfulfilled和onrejected只调用一次。 * * @param &#123;Function&#125; fn * @param &#123;Function&#125; onFulfilled * @param &#123;Function&#125; onRejected */ function doResolve(fn, onFulfilled, onRejected) &#123; var done = false; try &#123; fn(function(value) &#123; if (done) return; done = true; onFulfilled(value); &#125;, function(reason) &#123; if (done) return; done = true; onRejected(reason); &#125;); &#125; catch(ex) &#123; if (done) return; done = true; onRejected(ex); &#125; &#125; 上面已经完成了一个完整的内部状态机，但我们并没有暴露一个方法去解析或则观察 Promise 。现在让我们开始解析 Promise ： 1234function Promise(fn) &#123; ... doResolve(fn, resolve, reject);&#125; 如你所见，我们复用了 doResolve，因为对于初始化的 fn 也要对其进行控制。fn 允许调用 resolve 或则 reject 多次，甚至抛出异常。这完全取决于我们去保证 promise 对象仅被 resolved 或则 rejected 一次，且状态不能随意改变。 目前，我们已经有了一个完整的状态机，但我们仍然没有办法去观察它的任何变化。我们最终的目标是实现 then 方法，但 done 方法似乎更简单，所以先实现它。我们的目标是实现 promise.done(onFullfilled, onRejected) : onFulfilled 和 onRejected 两者只能有一个被执行，且执行次数为一次 该方法仅能被调用一次 一旦调用了该方法，则 promise 链式调用结束 无论是否 promise 已经被解析，都可以调用该方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869var PENDING = 0; // 进行中 var FULFILLED = 1; // 成功 var REJECTED = 2; // 失败function Promise() &#123; // 存储PENDING, FULFILLED或者REJECTED的状态 var state = PENDING; // 存储成功或失败的结果值 var value = null; // 存储成功或失败的处理程序，通过调用`.then`或者`.done`方法 var handlers = []; // 成功状态变化 function fulfill(result) &#123; state = FULFILLED; value = result; handlers.forEach(handle); handlers = null; &#125; // 失败状态变化 function reject(error) &#123; state = REJECTED; value = error; handlers.forEach(handle); handlers = null; &#125; function resolve(result) &#123; try &#123; var then = getThen(result); if (then) &#123; doResolve(then.bind(result), resolve, reject) return &#125; fulfill(result); &#125; catch (e) &#123; reject(e); &#125; &#125; // 不同状态，进行不同的处理 function shandle(handler) &#123; if (state === PENDING) &#123; handlers.push(handler); &#125; else &#123; if (state === FULFILLED &amp;&amp; typeof handler.onFulfilled === 'function') &#123; handler.onFulfilled(value); &#125; if (state === REJECTED &amp;&amp; typeof handler.onRejected === 'function') &#123; handler.onRejected(value); &#125; &#125; &#125; this.done = function (onFulfilled, onRejected) &#123; // 保证异步 setTimeout(function () &#123; handle(&#123; onFulfilled: onFulfilled, onRejected: onRejected &#125;); &#125;, 0); &#125; doResolve(fn, resolve, reject);&#125; 当 Promise 被 resolved 或者 rejected 时，我们保证 handlers 将被通知。 现在我们已经实现了 done 方法，下面实现 then 方法就很容易了。需要注意的是，要在处理程序中新建一个Promise 。123456789101112131415161718192021222324252627this.then = function (onFulfilled, onRejected) &#123; var self = this; return new Promise(function (resolve, reject) &#123; return self.done(function (result) &#123; if (typeof onFulfilled === 'function') &#123; try &#123; // onFulfilled方法要有返回值！ return resolve(onFulfilled(result)); &#125; catch (ex) &#123; return reject(ex); &#125; &#125; else &#123; return resolve(result); &#125; &#125;, function (error) &#123; if (typeof onRejected === 'function') &#123; try &#123; return resolve(onRejected(error)); &#125; catch (ex) &#123; return reject(ex); &#125; &#125; else &#123; return reject(error); &#125; &#125;); &#125;);&#125; 测试完成了上面的代码，测试就很容易了。测试实例来自MDN：1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;&lt;meta charset="UTF-8"&gt;&lt;title&gt;promise test&lt;/title&gt;&lt;script src="./mypromise.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;button id="test"&gt;promise test&lt;/button&gt;&lt;div id="log"&gt;&lt;/div&gt;&lt;script&gt; var promiseCount = 0; function testPromise() &#123; var thisPromiseCount = ++promiseCount; var log = document.getElementById('log'); log.insertAdjacentHTML('beforeend', thisPromiseCount + ') 开始(同步代码开始)'); var p1 = new Promise( function(resolve, reject) &#123; log.insertAdjacentHTML('beforeend', thisPromiseCount + ') Promise开始(异步代码开始)'); window.setTimeout(function() &#123; resolve(thisPromiseCount); &#125;, Math.random() * 2000 + 1000); &#125; ); p1.then( function(val) &#123; log.insertAdjacentHTML('beforeend', val + ') Promise被满足了(异步代码结束)'); &#125; ); log.insertAdjacentHTML('beforeend', thisPromiseCount + ') 建立了Promise(同步代码结束)'); &#125; document.querySelector('button').addEventListener('click', testPromise); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 效果： 结语通过一份简易的实现代码，理解Promise 原理还是挺容易的。全部代码 ！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[MongoDB基本命令]]></title>
      <url>%2F2016%2F12%2F22%2FMongoDB%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4%2F</url>
      <content type="text"><![CDATA[安装与启动下载Mongodb成功安装并启动MongoDB后，再打开一个命令行窗口进入mongodb安装目录bin文件夹下输入mongo，就可以进行数据库的一些操作。 基本命令输入help可以看到基本操作命令：show dbs 显示数据库列表show collections 显示当前数据库中的集合（类似关系数据库中的表）show users 显示用户use &lt;db name&gt; 切换当前数据库，这和MS-SQL里面的意思一样db.help() 显示数据库操作命令，里面有很多的命令db.foo.help() 显示集合操作命令，同样有很多的命令，foo指的是当前数据库下，一个叫foo的集合，并非真正意义上的命令db.foo.find() 对于当前数据库中的foo集合进行数据查找（由于没有条件，会列出所有数据）db.foo.find( { a : 1 } ) 对于当前数据库中的foo集合进行查找，条件是数据中有一个属性叫a，且a的值为1MongoDB没有创建数据库的命令，但有类似的命令。如：如果你想创建一个myTest的数据库，先运行use myTest命令，之后就做一些操作（如：db.createCollection(&#39;user&#39;)）,这样就可以创建一个名叫myTest的数据库。 常用命令Help查看命令提示12345help db.help(); db.yourColl.help(); db.youColl.find().help(); rs.help(); 切换/创建数据库1use yourDB; 当创建一个集合(table)的时候会自动创建当前数据库 查询所有数据库1show dbs; 删除当前使用数据库1db.dropDatabase(); 从指定主机上克隆数据库1db.cloneDatabase(&quot;127.0.0.1&quot;); 将指定机器上的数据库的数据克隆到当前数据库 从指定的机器上复制指定数据库数据到某个数据库1db.copyDatabase("mydb", "temp", "127.0.0.1");将本机的mydb的数据复制到temp数据库中 修复当前数据库1db.repairDatabase(); 查看当前使用的数据库12db.getName();db; db和getName方法是一样的效果，都可以查询当前使用的数据库 显示当前db状态1db.stats(); 当前db版本1db.version(); 查看当前db的链接机器地址1db.getMongo(); Collection集合创建一个聚集集合（table）1db.createCollection(&quot;collName&quot;, &#123;size: 20, capped: 5, max: 100&#125;); 得到指定名称的聚集集合（table）1db.getCollection(&quot;account&quot;); 得到当前db的所有聚集集合1db.getCollectionNames(); 显示当前db所有聚集索引的状态1db.printCollectionStats(); 用户相关添加一个用户12db.addUser(&quot;name&quot;);db.addUser(&quot;userName&quot;, &quot;pwd123&quot;, true); 添加用户、设置密码、是否只读 数据库认证、安全模式1db.auth(&quot;userName&quot;, &quot;123123&quot;); 显示当前所有用户1show users; 删除用户1db.removeUser(&quot;userName&quot;); 其他查询之前的错误信息1db.getPrevError(); 清除错误记录1db.resetError(); 查看集合基本信息1、查看帮助 db.yourColl.help();2、查询当前集合的数据条数 db.yourColl.count();3、查看数据空间大小 db.userInfo.dataSize();4、得到当前聚集集合所在的db db.userInfo.getDB();5、得到当前聚集的状态 db.userInfo.stats();6、得到聚集集合总大小 db.userInfo.totalSize();7、聚集集合储存空间大小 db.userInfo.storageSize();8、Shard版本信息 db.userInfo.getShardVersion()9、聚集集合重命名 db.userInfo.renameCollection(&quot;users&quot;); 将userInfo重命名为users10、删除当前聚集集合 db.userInfo.drop(); 集合查询查询所有记录1db.userInfo.find(); 相当于：select* from userInfo;默认每页显示20条记录，当显示不下的情况下，可以用it迭代命令查询下一页数据。注意：键入it命令不能带“；”但是你可以设置每页显示数据的大小，用DBQuery.shellBatchSize= 50;这样每页就显示50条记录了。 查询去掉后的当前聚集集合中的某列的重复数据1db.userInfo.distinct(&quot;name&quot;); 会过滤掉name中的相同数据相当于：select distict name from userInfo; 查询age = 22的记录1db.userInfo.find(&#123;&quot;age&quot;: 22&#125;); 相当于： select * from userInfo where age = 22; 查询age &gt; 22的记录1db.userInfo.find(&#123;age: &#123;$gt: 22&#125;&#125;); 相当于：select * from userInfo where age &gt;22; 查询age &lt; 22的记录1db.userInfo.find(&#123;age: &#123;$lt: 22&#125;&#125;); 相当于：select * from userInfo where age &lt;22; 查询age &gt;= 25的记录1db.userInfo.find(&#123;age: &#123;$gte: 25&#125;&#125;); 相当于：select * from userInfo where age &gt;= 25; 查询age &lt;= 25的记录1db.userInfo.find(&#123;age: &#123;$lte: 25&#125;&#125;); 查询age &gt;= 23 并且 age &lt;= 261db.userInfo.find(&#123;age: &#123;$gte: 23, $lte: 26&#125;&#125;); 查询name中包含 mongo的数据1db.userInfo.find(&#123;name: /mongo/&#125;); 相当于:select * from userInfo where name like ‘%mongo%’; 查询name中以mongo开头的1db.userInfo.find(&#123;name: /^mongo/&#125;); 相当于：select * from userInfo where name like ‘mongo%’; 查询指定列name、age数据1db.userInfo.find(&#123;&#125;, &#123;name: 1, age: 1&#125;); 相当于：select name, age from userInfo;当然name也可以用true或false,当用ture的情况下河name:1效果一样，如果用false就是排除name，显示name以外的列信息。 查询指定列name、age数据, age &gt; 251db.userInfo.find(&#123;age: &#123;$gt: 25&#125;&#125;, &#123;name: 1, age: 1&#125;); 相当于：select name, age from userInfo where age &gt;25; 按照年龄排序12升序：db.userInfo.find().sort(&#123;age: 1&#125;);降序：db.userInfo.find().sort(&#123;age: -1&#125;); 查询name = zhangsan, age = 22的数据1db.userInfo.find(&#123;name: &apos;zhangsan&apos;, age: 22&#125;); 相当于：select * from userInfo where name = ‘zhangsan’ and age = ‘22’; 查询前5条数据1db.userInfo.find().limit(5); 相当于：selecttop 5 * from userInfo; 查询10条以后的数据1db.userInfo.find().skip(10); 相当于：select from userInfo where id not in (selecttop 10 from userInfo); 查询在5-10之间的数据1db.userInfo.find().limit(10).skip(5); 可用于分页，limit是pageSize，skip是第几页*pageSize or与 查询1db.userInfo.find(&#123;$or: [&#123;age: 22&#125;, &#123;age: 25&#125;]&#125;); 相当于：select * from userInfo where age = 22 or age = 25; 查询第一条数据1db.userInfo.findOne(); 相当于：selecttop 1 * from userInfo;db.userInfo.find().limit(1); 查询某个结果集的记录条数1db.userInfo.find(&#123;age: &#123;$gte: 25&#125;&#125;).count(); 相当于：select count(*) from userInfo where age &gt;= 20; 按照某列进行排序1db.userInfo.find(&#123;sex: &#123;$exists: true&#125;&#125;).count(); 相当于：select count(sex) from userInfo; 索引创建索引12db.userInfo.ensureIndex(&#123;name: 1&#125;);db.userInfo.ensureIndex(&#123;name: 1, ts: -1&#125;); 查询当前聚集集合所有索引1db.userInfo.getIndexes(); 查看总索引记录大小1db.userInfo.totalIndexSize(); 读取当前集合的所有index信息1db.users.reIndex(); 删除指定索引1db.users.dropIndex(&quot;name_1&quot;); 删除所有索引索引1db.users.dropIndexes(); 修改、添加、删除集合数据添加1db.users.save(&#123;name: ‘zhangsan’, age: 25, sex: true&#125;); 添加的数据的数据列，没有固定，根据添加的数据为准 修改1db.users.update(&#123;age: 25&#125;, &#123;$set: &#123;name: &apos;changeName&apos;&#125;&#125;, false, true); 相当于：update users set name = ‘changeName’ where age = 25;1db.users.update(&#123;name: &apos;Lisi&apos;&#125;, &#123;$inc: &#123;age: 50&#125;&#125;, false, true); 相当于：update users set age = age + 50 where name = ‘Lisi’;1db.users.update(&#123;name: &apos;Lisi&apos;&#125;, &#123;$inc: &#123;age: 50&#125;, $set: &#123;name: &apos;hoho&apos;&#125;&#125;, false, true); 相当于：update users set age = age + 50, name = ‘hoho’ where name = ‘Lisi’; 删除1db.users.remove(&#123;age: 132&#125;); 查询修改删除12345678910111213db.users.findAndModify(&#123; query: &#123;age: &#123;$gte: 25&#125;&#125;, sort: &#123;age: -1&#125;, update: &#123;$set: &#123;name: &apos;a2&apos;&#125;, $inc: &#123;age: 2&#125;&#125;, remove: true&#125;); db.runCommand(&#123; findandmodify : &quot;users&quot;, query: &#123;age: &#123;$gte: 25&#125;&#125;, sort: &#123;age: -1&#125;, update: &#123;$set: &#123;name: &apos;a2&apos;&#125;, $inc: &#123;age: 2&#125;&#125;, remove: true&#125;); update 或 remove 其中一个是必须的参数; 其他参数可选。 参数 详解 默认值 query 查询过滤条件 {} sort 如果多个文档符合查询过滤条件，将以该参数指定的排列方式选择出排在首位的对象，该对象将被操作 {} remove 若为true，被选中对象将在返回前被删除 N/A update 一个 修改器对象 N/A new 若为true，将返回修改后的对象而不是原始对象。在删除操作中，该参数被忽略。 false fields 参见Retrieving a Subset of Fields (1.5.0+) All fields upsert 创建新对象若查询结果为空。 示例 (1.5.4+) false 语句块操作简单Hello World1print(&quot;Hello World!&quot;); 这种写法调用了print函数，和直接写入”Hello World!”的效果是一样的； 将一个对象转换成json12tojson(new Object());tojson(new Object(&apos;a&apos;)); 循环添加数据123for (var i = 0; i &lt; 30; i++) &#123; db.users.save(&#123;name: &quot;u_&quot; + i, age: 22 + i, sex: i % 2&#125;);&#125;; 这样就循环添加了30条数据，同样也可以省略括号的写法1for (var i = 0; i &lt; 30; i++) db.users.save(&#123;name: &quot;u_&quot; + i, age: 22 + i, sex: i % 2&#125;); 也是可以的，当你用db.users.find()查询的时候，显示多条数据而无法一页显示的情况下，可以用it查看下一页的信息； find 游标查询1234var cursor = db.users.find();while (cursor.hasNext()) &#123; printjson(cursor.next()); &#125; 这样就查询所有的users信息，同样可以这样写12var cursor = db.users.find();while (cursor.hasNext()) &#123; printjson(cursor.next); &#125; 同样可以省略{}号 forEach迭代循环1db.users.find().forEach(printjson); forEach中必须传递一个函数来处理每条迭代的数据信息 将find游标当数组处理12var cursor = db.users.find();cursor[4]; //取得下标索引为4的那条数据 既然可以当做数组处理，那么就可以获得它的长度：cursor.length();或者cursor.count();那样我们也可以用循环显示数据1for (var i = 0, len = c.length(); i &lt; len; i++) printjson(c[i]); 将find游标转换成数组12var arr = db.users.find().toArray();//用toArray方法将其转换为数组printjson(arr[2]); 定制我们自己的查询结果只显示age &lt;= 28的并且只显示age这列数据1234db.users.find(&#123;age: &#123;$lte: 28&#125;&#125;, &#123;age: 1&#125;).forEach(printjson);db.users.find(&#123;age: &#123;$lte: 28&#125;&#125;, &#123;age: true&#125;).forEach(printjson);//排除age的列db.users.find(&#123;age: &#123;$lte: 28&#125;&#125;, &#123;age: false&#125;).forEach(printjson); forEach传递函数显示信息1db.things.find(&#123;x:4&#125;).forEach(function(x) &#123;print(tojson(x));&#125;);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[实时通讯之Socket.io]]></title>
      <url>%2F2016%2F12%2F22%2F%E5%AE%9E%E6%97%B6%E9%80%9A%E8%AE%AF%E4%B9%8BSocket-io%2F</url>
      <content type="text"><![CDATA[WebSocketWebSocket是HTML5开始提供的一种浏览器与服务器间进行全双工通讯的网络技术。使用 WebSocket ，浏览器和服务器只需要要做一个握手的动作，然后，浏览器和服务器之间就形成了一条快速通道，两者之间就直接可以数据互相传送。而且它为我们实现即时服务带来了两大好处： 节省资源：互相沟通的Header是很小的-大概只有 2 Bytes。 推送信息：不需要客户端请求，服务器可以主动传送数据给客户端。 Socket.ioSocket.IO是一个WebSocket库，包括了客户端的js和服务器端的nodejs，它的目标是构建可以在不同浏览器和移动设备上使用的实时应用。 服务监听socket.io的服务端启动非常的简单，引用socket.io模块。然后调用listen函数，传入监听的端口号，开始服务监听。1var io = require('socket.io')(80); 注册事件connection事件在客户端成功连接到服务端时触发，有了这个事件，我们可以随时掌握用户连接到服务端的信息。当客户端成功建立连接时，在connection事件的回调函数中，我们还是可以为socket注册一些常用的事件,如：disconnect事件，它在客户端连接断开时触发，这时候我就知道用户已经离开了。1234567var io = require('socket.io')(80);io.on('connection',function(socket)&#123; //连接成功... socket.on('disconnect',function()&#123; //用户已经离开... &#125;);&#125;); 启动服务为了在浏览器中能够访问到我们的服务，我们还需要在服务端搭建一个简单的web服务器，让浏览器能够访问我们的客户端页面。为了便捷，我们选用node.js中常用的express框架来实现web服务，示例如下：1234567891011var express = require('express');var app = express();app.get('/',function(req,res)&#123; res.status(200).send('欢迎！');&#125;);var server = require('http').createServer(app);var io = require('socket.io')(server);io.on('connection',function(socket)&#123; //do something&#125;);server.listen(80); 客户端引用服务端运行后会在根目录动态生成socket.io的客户端js文件，客户端可以通过固定路径/socket.io/socket.io.js添加引用。首先添加网页index.html,并在网页中引用客户端js文件：1&lt;script src="/socket.io/socket.io.js"&gt;&lt;/script&gt; 当然这样的客户端引用方式并不是必须的，我们也可以引用官方的cdn或者下载到本地的客户端文件。一般情况下推荐引用动态生成的客户端文件，因为这样客户端和服务端的版本可以保持一致，减少出错的几率。1&lt;script src="https://cdn.socket.io/socket.io-1.2.1.js"&gt;&lt;/script&gt; 连接服务当客户端成功加载socket.io客户端文件后会获取到一个全局对象io，我们将通过io.connect函数来向服务端发起连接请求。1234567var socket = io.connect('/');socket.on('connect',function()&#123; //连接成功&#125;);socket.on('disconnect',function(data)&#123; //连接断开&#125;); connect函数可以接受一个url参数，url可以socket服务的http完整地址，也可以是相对路径，如果省略则表示默认连接当前路径。与服务端类似，客户端也需要注册相应的事件来捕获信息，不同的是客户端连接成功的事件是connect。 实时通讯当我们成功建立连接后，我们可以通过socket对象的send函数来互相发送消息，示例-客户端向服务端发送消息(index.html)：12345678var socket = io.connect('/');socket.on('connect',function()&#123; //客户端连接成功后发送消息'hello world!' socket.send('hello world!');&#125;);socket.on('message',function(data)&#123; alert(data);&#125;); 连接成功后，我们向服务端发送消息hello world!，还为socket注册了message事件，它是send函数对应的接收消息的事件，当服务端向客户端send消息时，我们就可以在message事件中接收到发送过来的消息。服务端向客户端发送消息也可以通过send的方式，示例 - 服务端向客户端发送消息(app.js)：12345678var io = require('scoket.io');io.on('connection',function(socket)&#123; socket.send('欢迎！'); socket.on('message',function(data)&#123; //收到消息 console.log(data); &#125;);&#125;); 与客户端相同，服务端也需要为socket注册message事件来接收客户端发送过来的消息。 发送信息socket.io既然是用来实现通讯的，那么如何发送、接收信息才是根本。在socket.io中，emit函数用于发送数据，还上述讲解中，我们使用send的方式实现了信息的互发，其实send函数只是emit的封装，实际上还是使用了emit，且看send函数是如何实现的：123456function send()&#123; var args = toArray(arguments); args.unshift('message'); this.emit.apply(this, args); return this;&#125; 在send函数中，获取到原来的参数，并在原来的基础上插入了一个参数message，然后调用了emit函数。通过send函数的实现，我们也学会了emit函数的用法，它有两个参数，第一个参数是事件名称，在接收端注册该事件就可以接收到发送过去的信息，事件名称可以自由定义，在不同的场景下，我们可以定义不同的事件来接收消息。第二个参数才是发送的数据。了解清楚了工作原理，下面来将send替换成emit函数发送信息：123456//app.jsio.on('connection',function(socket)&#123; socket.emit('message','连接成功！'); socket.on('message',function(data)&#123; &#125;);&#125;); 服务端事件事件监听是实现通讯的基础。在一些关键的的状态下，socket.io可以注册相应的事件，通过事件监听，我们可以在这些事件中作出反应，常用的事件如下： 事件 描述 connection 客户端成功连接到服务器。 message 捕获客户端send信息。 disconnect 客户端断开连接。 error 发生错误。 客户端事件较服务端而言，客户端提供更多的监听事件，在实时应用中，我们可以为这些事件注册监听并作出反应。 事件 描述 connect 成功连接到服务器。 connecting 正在连接。 disconnect 断开连接。 connect_failed 连接失败。 error 连接错误。 message 监听服务端send的信息。 reconnect_failed 重新连接失败。 reconnect 重新连接成功。 reconnecting 正在重连。 那么客户端socket发起连接时的顺序是怎么样的呢？当第一次连接时，事件触发顺序为：connecting → connect当失去连接时，事件触发顺序为：disconnect → reconnecting →connecting → reconnect → connect 命名空间命名空间着实是一个非常实用好用的功能。我们可以通过命名空间，划分出不同的房间，在房间里的广播和通信都不会影响到房间以外的客户端。在服务端，通过of(&quot;&quot;)的方式来划分新的命名空间：12io.of('chat').on('connection',function(socket)&#123;&#125;); 示例中，我们创建一个名为chat的房间，客户端可以通过如下方式连接到指定的房间：1var socket = io.connect('/chat'); 虽然连接到指定的房间，但是我们也可以在服务端操作，自由的进出房间：12socket.join('chat');//进入chat房间socket.leave('chat');//离开chat房间 广播消息在实时应用中，广播是一个不可或缺的功能，socket.io提供两种服务端广播方式。第一种广播方式可以称之为’全局广播’，顾名思义，全局广播就是所有连接到服务器的客户端都会受到广播的信息：1socket.broadcast.emit('DATA',data); 但是，在实际应用场景中，我们很多时候并不需要所有用户都收到广播信息，有的广播信息只发送给一部分客户端，比如某个房间里面的用户，那么可以使用如下方式：1socket.broadcast.to('chat').emit('DATA',data); 当使用to()的方式广播信息时，只有该命名空间下的客户端才会收到广播信息，是不是很方便呢。 传递参数在很多应用场景中，客户端发起连接请求时都需要传递参数，这些参数可能是身份验证、初始化设置等等，那么socket.io发起连接时如何传递参数呢？1var socket = io.connect('/'); 由于connect函数发起连接的参数是一个url，你可能会想到把参数拼接到url上，如http://xxxx?xx=xxxx，但是很遗憾这样是行不通的，我们可以通过这样的方式来传递参数：1var socket = io.connect('/',&#123; _query:'sid=123456' &#125;); 在服务端可以这样获取到传递的参数:1234io.use(function(socket)&#123; var query = socket.request._query; var sid = query.sid; &#125;); 客户端传递的参数已经被解析成了一个json对象，这个对象就是_query。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[模块module.exports与实例化方法]]></title>
      <url>%2F2016%2F12%2F21%2F%E6%A8%A1%E5%9D%97module-exports%E4%B8%8E%E5%AE%9E%E4%BE%8B%E5%8C%96%E6%96%B9%E6%B3%95%2F</url>
      <content type="text"><![CDATA[在nodejs中，提供了exports 和 require 两个对象，其中 exports 是模块公开的接口，require 用于从外部获取一个模块的接口，即所获取模块的 exports 对象。而在exports抛出的接口中，如果你希望你的模块就想为一个特别的对象类型，请使用module.exports；如果希望模块成为一个传统的模块实例，请使用exports.xx方法；module.exports才是真正的接口，exports只不过是它的一个辅助工具。最终返回给调用的是module.exports而不是exports。下面看代码；首先来看module.exports，新建一个hello.js，代码如下： 12345678module.exports=function(name,age,money)&#123; this.name=name; this.age=age; this.money=money; this.say=function()&#123; console.log('我的名字叫：'+this.name+'，我今年'+this.age+'岁，月薪为：'+this.money+'元；') &#125;&#125;; 可以看到，module.exports被赋予了一个构造函数；再新建一个main.js，其中引入hello.js这个模块，把exports方法接受进来，main.js代码如下： 123var Hello=require('./hello');var hello=new Hello('jone','24','10000')hello.say(); 进入node环境，运行main.js，可以看到，已经打印出来：我的名字叫：jone，我今年24岁，月薪为：10000元；而在hello.js中，我们是赋予了exports一个函数 ，当然，也可以采用匿名函数的方式；见代码：123456789function hello(name,age,money)&#123; this.name=name; this.age=age; this.money=money; this.say=function()&#123; console.log('我的名字叫：'+this.name+'，我今年'+this.age+'岁，月薪为：'+this.money+'元；') &#125;&#125;module.exports=hello; 以上module.exports，这个模块很明显是一个特别的对象模型；那如果采用对象实例的方法该如何实现呢？其实也很简单，只需要给exports对象赋值一个新的方法即可；见下面代码： 12345678910function hello(name,age,money)&#123; this.name=name; this.age=age; this.money=money; this.say=function()&#123; console.log('我的名字叫：'+this.name+'，我今年'+this.age+'岁，月薪为：'+this.money+'元；') &#125;&#125;var Hello=new hello('jone','24','10000');exports.add=Hello 在hello.js中，依然是一个构造函数，声明了一个变量Hello，然后再把Hello赋值给exports自定义的add方法；那么在main.js中，由于add已经是exports的一个自定义的实例方法了，因此我们可以直接这么调用它：Hello.add.say()；见代码：12var Hello=require(&apos;./hello&apos;);Hello.add.say() 进行node环境，运行main.js，可以看到，结果和上面一样，都会输出：我的名字叫：jone，我今年24岁，月薪为：10000元；]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[D3入门总结]]></title>
      <url>%2F2016%2F12%2F21%2FD3%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93%2F</url>
      <content type="text"><![CDATA[D3.js 是基于数据操作文档的 JavaScript 库，通过 HTML、SVG 和 CSS 赋予数据以生命。D3 集强力的可视化组件与数据驱动型的 DOM 操作手法于一身，能最大限度地引出现代浏览器的性能，而不必束缚于特定的框架。 基础选择元素1d3.select() 选择所有指定元素的第一个1d3.selectAll() 选择指定元素的全部 绑定元素1data() 绑定一个数组到选择集上，数组的各项值分别与选择集的各元素绑定1dataum() 绑定一个数据到选择集上1function(d, i)&#123; &#125; 当选择集需要使用被绑定的数据时，常需要使用匿名函数。其包含两个参数，其中：d 代表数据，也就是与某元素绑定的数据i 代表索引，代表数据的索引号，从 0 开始 插入元素1append() 在选择集末尾插入元素 1insert() 在选择集前面插入元素 删除元素1remove() 添加画布1234var svg = d3.select("body") //选择文档中的body元素 .append("svg") //添加一个svg元素 .attr("width", 300) //设定宽度 .attr("height", 300); //设定高度 绘制矩形12345var dataset = [ 250 , 210 , 170 , 130 , 90 ]; svg.selectAll("rect") //选择svg内所有的矩形 .data(dataset) //绑定数组 .enter() //指定选择集的enter部分 .append("rect") //添加足够数量的矩形元素 有数据，而没有足够图形元素的时候，使用此方法可以添加足够的元素。 矩形的属性，常用的有四个： x - 矩形左上角的 x 坐标 y - 矩形左上角的 y 坐标 width - 矩形的宽度 height - 矩形的高度 注意，在 SVG 中，x 轴的正方向是水平向右，y 轴的正方向是垂直向下的。 比例尺缩放1d3.scale.linear() 返回一个线性比例尺12domain()range() 设定比例尺的定义域和值域12d3.max()d3.min() 求数组的最大值和最小值 线性比例尺1234567891011var dataset = [1.2, 2.3, 0.9, 1.5, 3.3];var min = d3.min(dataset);var max = d3.max(dataset);var linear = d3.scale.linear() .domain([min, max]) .range([0, 300]); linear(0.9); //返回 0linear(2.3); //返回 175linear(3.3); //返回 300 上面的方法将dataset中最小的值，映射成0；将最大的值，映射成 300。 d3.scale.linear() 的返回值，是可以当做函数来使用的。因此，有这样的用法：linear(2.3)，返回175。 序数比例尺12345678910var index = [0, 1, 2, 3, 4];var color = ["red", "blue", "green", "yellow", "black"];var ordinal = d3.scale.ordinal() .domain(index) .range(color);ordinal(0); //返回 redordinal(2); //返回 greenordinal(4); //返回 black 定义坐标轴1d3.svg.axis() D3 中坐标轴的组件，能够在 SVG 中生成组成坐标轴的元素。 要生成坐标轴，需要用到比例尺，它们二者经常是一起使用的。12345678910var dataset = [ 2.5 , 2.1 , 1.7 , 1.3 , 0.9 ];//定义比例尺var linear = d3.scale.linear() .domain([0, d3.max(dataset)]) .range([0, 250]);//定义坐标轴var axis = d3.svg.axis() .scale(linear) //指定比例尺 .orient("bottom") //指定刻度的方向 .ticks(7); //指定刻度的数量 scale()：指定比例尺。 orient()：指定刻度的朝向，bottom 表示在坐标轴的下方显示。 ticks()：指定刻度的数量。 定义了坐标轴之后，只需要在 SVG 中添加一个分组元素 ，再将坐标轴的其他元素添加到这个 里即可1svg.append("g").call(axis); 在 D3 中，call() 的参数是一个函数,调用之后，将当前的选择集作为参数传递给此函数 完整的柱形图 添加 SVG 画布12345678var width = 400;var height = 400;var padding = &#123;left:30, right:30, top:20, bottom:20&#125;;//在 body 里添加一个 SVG 画布 var svg = d3.select("body") .append("svg") .attr("width", width) .attr("height", height); 定义数据和比例尺123456789var dataset = [10, 20, 30, 40, 33, 24, 12, 5];//x轴的比例尺var xScale = d3.scale.ordinal() .domain(d3.range(dataset.length)) .rangeRoundBands([0, width - padding.left - padding.right]);//y轴的比例尺var yScale = d3.scale.linear() .domain([0,d3.max(dataset)]) .range([height - padding.top - padding.bottom, 0]); 定义坐标轴123456789//定义x轴var xAxis = d3.svg.axis() .scale(xScale) .orient("bottom"); //定义y轴var yAxis = d3.svg.axis() .scale(yScale) .orient("left"); 添加矩形和文字元素12345678910111213141516171819202122232425262728293031323334353637383940414243//矩形之间的空白var rectPadding = 4;//添加矩形元素var rects = svg.selectAll(".MyRect") .data(dataset) .enter() .append("rect") .attr("class","MyRect") .attr("transform","translate(" + padding.left + "," + padding.top + ")") .attr("x", function(d,i)&#123; return xScale(i) + rectPadding/2; &#125; ) .attr("y",function(d)&#123; return yScale(d); &#125;) .attr("width", xScale.rangeBand() - rectPadding ) .attr("height", function(d)&#123; return height - padding.top - padding.bottom - yScale(d); &#125;);//添加文字元素var texts = svg.selectAll(".MyText") .data(dataset) .enter() .append("text") .attr("class","MyText") .attr("transform","translate(" + padding.left + "," + padding.top + ")") .attr("x", function(d,i)&#123; return xScale(i) + rectPadding/2; &#125; ) .attr("y",function(d)&#123; return yScale(d); &#125;) .attr("dx",function()&#123; return (xScale.rangeBand() - rectPadding)/2; &#125;) .attr("dy",function(d)&#123; return 20; &#125;) .text(function(d)&#123; return d; &#125;); 添加坐标轴的元素1234567891011//添加x轴svg.append("g") .attr("class","axis") .attr("transform","translate(" + padding.left + "," + (height - padding.bottom) + ")") .call(xAxis); //添加y轴svg.append("g") .attr("class","axis") .attr("transform","translate(" + padding.left + "," + padding.top + ")") .call(yAxis); 过渡效果1transition() 启动过渡效果。 其前后是图形变化前后的状态（形状、位置、颜色等等）1duration() 指定过渡的持续时间，单位为毫秒。1ease() 指定过渡的方式，常用的有： linear：普通的线性变化 circle：慢慢地到达变换的最终状态 elastic：带有弹跳的到达最终状态 bounce：在最终状态处弹跳几次1delay() 指定延迟的时间，表示一定时间后才开始转变，单位同样为毫秒。此函数可以对整体指定延迟，也可以对个别指定延迟。 Update、Enter、Exit如果数组为 [3, 6, 9, 12, 15]，将此数组绑定到3个 p 元素的选择集上。可以想象，会有两个数据没有元素与之对应，这时候 D3 会建立两个空的元素与数据对应，这一部分就称为 Enter。而有元素与数据对应的部分称为 Update。 如果数组为 [3]，则会有两个元素没有数据绑定，那么没有数据绑定的部分被称为 Exit。 update 部分的处理办法一般是：更新属性值 enter 部分的处理办法一般是：添加元素后，赋予属性值 exit 部分的处理办法一般是：删除元素（remove）]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[移动端手势库Hammer.js]]></title>
      <url>%2F2016%2F12%2F18%2F%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%89%8B%E5%8A%BF%E5%BA%93Hammer-js%2F</url>
      <content type="text"><![CDATA[Github Hammer.js是一个开源的，轻量级的javascript库，它可以在不需要依赖其他东西的情况下识别触摸，鼠标事件。 使用引入hammer.js到文件中，并创建一个新的实例：1234var hammer = new Hammer(Element, Options);hammer.on('tap', function(ev) &#123; console.log(ev);&#125;); hammerjs内置多种手势识别器，包括 tap：轻触，与click相比有300ms的延迟 doubletap：双点击 press：按住,最小按压时间为500毫秒 pan：拖动平移 panstart：拖动开始 panmove：拖动过程 panend：拖动结束 pancancel：拖动取消 panleft：向左拖动 panright：向右拖动 panup：向上拖动 pandown：向下拖动 swipe：快速滑动 swipeleft：向左滑动 swiperight：向右滑动 swipeup：向上滑动 swipedown：向下滑动 pinch：多触点捏放 pinchstart：多点触控开始 pinchmove：多点触控过程 pinchend：多点触控结束 pinchcancel：多点触控取消 pinchin：多点触控时两手指距离越来越近 pinchout：多点触控时两手指距离越来越远 rotate：旋转识别器 rotatestart：旋转开始 rotatemove：旋转过程 rotateend：旋转结束 rotatecancel：旋转取消 其中 pinch 和 rotate 默认是不可用的，想启用它们，需要加上： 12hammer.get('pinch').set(&#123; enable: true &#125;);hammer.get('rotate').set(&#123; enable: true &#125;); pan 和 swipe默认只识别水平方位的手势，若要允许识别器识别垂直方位或全部方位的 pan 和 swipe，可以这么写： 12hammer.get('pan').set(&#123; direction: Hammer.DIRECTION_ALL &#125;);hammer.get('swipe').set(&#123; direction: Hammer.DIRECTION_VERTICAL &#125;); 另建议加上如下meta标签，防止doubletap 或 pinch 缩放了viewport： 1&lt;meta name="viewport" content="user-scalable=no, width=device-width, initial-scale=1, maximum-scale=1"&gt; 事件对象 每一个Hammer触发的事件都会收到一个包含了如下属性的事件对象： on(events, handler) 和 .off(events, [handler]) 监听由被添加的识别器触发的事件，或者移除那些绑定了的事件。参数中将事件通过空格隔开可处理多个事件 在jQuery基础上使用123456$("#element").hammer(&#123; // 对DOM进行一些初始化，这里可以加入一些参数 &#125;) .on("tap", function(ev) &#123; console.log(ev); &#125;);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hexo博客命令]]></title>
      <url>%2F2016%2F12%2F10%2Fhello-world%2F</url>
      <content type="text"><![CDATA[写在第一页，作为建立个人博客的第一篇文章，使用Hexo搭建，记录日常使用的常用命令。本博客使用品Next主题。精于心，简于形 快速开始创建新文章1$ hexo new post "My New Post" 创建新页面1$ hexo new page "My New Page" 更多信息 启动服务器1$ hexo server 更多信息 生成静态文件1$ hexo generate 更多信息 发布到远程服务器1$ hexo deploy 更多信息]]></content>
    </entry>

    
  
  
</search>
